Title: 排序-希尔排序法
Date:2009-10-1
Author:李鹏
Slug: 排序
Tags:算法
category:算法

### （一）算法讲解

原始的算法实现在最坏的情况下需要进行O(n2)的比较和交换。V. Pratt的书[1] 对算法进行了少量修改，可以使得性能提升至O(n log2 n)。这比最好的比较算法的O(n log n)要差一些。

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。

假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。

一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++）。

例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：

13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10

然后我们对每列进行排序：

10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45

将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：

10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45

排序之后变为：

10 14 13 25 23 33 27 25 59 39 65 73 45 94 82 94

最后以1步长进行排序（此时就是简单的插入排序了）。 步长串行

步长的选择是希尔排序的重要部分。只要最终步长为1任何步长串行都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。

Donald Shell 最初建议步长选择为\frac{n}{2}并且对步长取半直到步长达到 1。虽然这样取可以比\mathcal{O}(n^2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。 可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。 步长串行 最坏情况下复杂度 {n/2^i} \mathcal{O}(n^2) 2^k - 1 \mathcal{O}(n^{3/2}) 2^i 3^j \mathcal{O}( n\log^2 n )

已知的最好步长串行是由Sedgewick提出的 (1, 5, 19, 41, 109,...)，该串行的项来自 9 * 4^i - 9 * 2^i + 1 和 4^i - 3 * 2^i + 1 这两个算式[1].这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长串行的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。

另一个在大数组中表现优异的步长串行是(斐波那契数列除去0和1将剩余的数以黄金分区比的两倍的幂进行运算得到的数列)：（1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713, …）[2] 伪代码

    input: an array a of length n with array elements numbered 0 to n ? 1
    inc ← round(n/2)
    while inc > 0 do:
        for i = inc .. n ? 1 do:
            temp ← a[i]
            j ← i
            while j ≥ inc and a[j ? inc] > temp do:
                a[j] ← a[j ? inc]
                j ← j ? inc
                a[j] ← temp
        inc ← round(inc / 2.2)

### （二）代码示例

#### （1）C示例代码

```c

    #include <stdio.h>
    int main()
    {
        const int n = 5;
        int i, j, temp;
        int gap = 0;
        int a[] = {5, 4, 3, 2, 1};
        while (gap<=n)
        {
            gap = gap * 3 + 1;
        }
        while (gap > 0)
            {
                 for ( i = gap; i < n; i++ )
                 {
                     j = i - gap;
                     temp = a[i];
                     while (( j >= 0 ) && ( a[j] > temp ))
                     {
                          a[j + gap] = a[j];
                          j = j - gap;
                     }
                     a[j + gap] = temp;
                 }
                 gap = ( gap - 1 ) / 3; }
    }
```

#### （2）C++示例代码

```c++

    void shellsort(int *data, size_t size)
    {
        for (int gap = size / 2; gap > 0; gap /= 2)
            for (int i = gap; i < size; ++i)
            {
                int key = data[i];
                int j = 0;
                for( j = i -gap; j >= 0 && data[j] > key; j -=gap)
                {
                    data[j+gap] = data[j];
                }
                data[j+gap] = key;
             }

    }
```

#### （3）Java中的示例代码

```java

    static void shellsort (int[] a, int n)
    {
        int temp;
        for(int i=n;i=0)
        {
            if(a[j]<a[j-n])
            {
                temp=a[j];
                a[j]=a[j-n];
                a[j-n]=temp;
            }
            j=j-n;
        }
     }
```

Top[^]()


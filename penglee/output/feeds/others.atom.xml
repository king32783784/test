<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>路漫求索</title><link href="http://king32783784.github.io/" rel="alternate"></link><link href="http://king32783784.github.io/feeds/others.atom.xml" rel="self"></link><id>http://king32783784.github.io/</id><updated>2017-03-11T00:00:00+08:00</updated><entry><title>测试的行业危机</title><link href="http://king32783784.github.io/2017/03/11/%E6%B5%8B%E8%AF%95/" rel="alternate"></link><published>2017-03-11T00:00:00+08:00</published><updated>2017-03-11T00:00:00+08:00</updated><author><name>Others</name></author><id>tag:king32783784.github.io,2017-03-11:2017/03/11/测试/</id><summary type="html">&lt;p&gt;经常看到网上时不时吵起“测试人员如何转产品”、“QA的长期职业规划”等文章，对于QA工程师而言，貌似都是老生常谈的内容了。原本抱着在某个“特殊时刻”（马桶上）消磨时光的心态点开了这篇文章，居然在如此“恶劣”的环境下用时15min耐心看完了之后，又返回电脑前默默把它左击放入收藏夹。&lt;/p&gt;
&lt;p&gt;到底这篇文章讲了什么呢？快收起小马步，听听华为资深测试专家怎么看待测试的行业危机：&lt;/p&gt;
&lt;p&gt;入职华为以来，一直做的是测试工作，这种危机感在近几年愈发强烈，一直想总结一下，但又担心总结不好，动摇军心。但该面对的早晚要面对，需改变的也要尽早改变，一定要有革自己命的勇气。&lt;/p&gt;
&lt;h3&gt;危机的预兆&lt;/h3&gt;
&lt;p&gt;举两个测试行业危机的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个是外部例子。近期参加了几个测试行业交流，测试技术分享方面并没有什么新的发展，还是自动化、APP 测试能力技术分享。业界的测试专家也普遍进入一个迷茫期，很多测试专家转型敏捷教练、DevOps 流程专家。和几个专家聊了一下，也普遍感觉近几年业界对测试的关注已经逐步偏弱。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另外一个是内部的例子。华为 2017 年应届生招聘已经启动，在启动材料中，明确说明华为已经取消了软件测试工程师的岗位，HR 认为现在的软件需要全栈工程师，开发工程师也需要具备自测的能力。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;危机产生的原因&lt;/h3&gt;
&lt;p&gt;测试行业发展的顶峰应该在 2000 年后，Google 测试体系大肆宣传的那几年，市面上到处都是 Google 测试的书籍，自动化测试能力也得到业界的高度认同，整个 IT 界都在推广自动化，一个测试专家仅靠自动化能力就会获得比较高的薪资。而近几年随着软件技术的快速发展，技术知识越来越容易获取，技术的迭代周期也不断加速，技术门槛也越来越低。在这种大背景下，专职测试的必要性也在不断受到挑战，特别对于一些创业类的小型公司，在没有专职测试的条件下，产品也能得到市场的认可。&lt;/p&gt;
&lt;p&gt;随着软件开源社区的快速发展，软件工具的易用性也在不断加强，各类开发和测试框架层出不穷，技术人员可以很方便的使用框架代码实现自己的需求，按照公司的说法是我们无需自己造轮子。各种轮子的使用，让业务开发变得更加便捷，这也是为什么华为的软件可以使用大量合作的原因，也许不久的将来，这个行业真的会变成劳动密集型行业，未来受到冲击的可能不仅仅是测试和运维，开发一样存在在行业危机。&lt;/p&gt;
&lt;p&gt;软件工程方法也在不断演进。以近期盛行的 DevOps 为例，该流程倡导一种全功能团队的运作模式，团队中的各个角色分工相对模糊，开发需要投入自测和运维，这种开发模式体现了及时响应，及时改进的快速迭代思想，提升了对开发的要求，但是对于运维和测试角色，造成了一定冲击。&lt;/p&gt;
&lt;p&gt;传统的软件测试，特别是通信类产品和大型的 To B 类软件，对交付质量较高，有很高的门槛。一个测试专家需要了解无线交换、数通网络、小型机、软件、各类信令。专家到各地开局时，往往是单枪匹马，一人搞定，受到办事处同事的敬仰膜拜。记得有次给客户演示 VPN 短号，业务服务器故障一直无法定位，征得客户的同意，直接在交换上做了一个号码变换，先解决演示的问题，当时测试人员要求的技术广度远超于开发人员。&lt;/p&gt;
&lt;p&gt;但是近几年，通信业已经无法阻挡软件化的趋势，随着 CT 技术门槛也在不断降低，华为也正喊出了 CT 转 IT 的口号。软件的微服务、云化等技术，让测试人员工作也不断简化，很多新来的同事对直接使用计算云部署环境，对物理服务器的了解也是一知半解，在知识广度方面可能和开发持平，而在深度方面，又不如开发，测试技术不在存在门槛，角色的必需性正在不断的弱化。&lt;/p&gt;
&lt;h3&gt;华为测试人员的现状&lt;/h3&gt;
&lt;p&gt;华为大部分部门的测试开发比在 1：3 或 1：4 这个比例，这在业界是比较高的，比例高有两方面原因，一方面是和我们的通信软件质量要求比较高有关，需要多轮的验证，需要大型解决方案的交付。另外一方面和华为的 IPD 流程相关，大量的测试交付件，大量的评审和会议，为了确保大家步调的一致性，行管部门还是定期进行飞检和数据晾晒。严谨的流程保障也是有利有弊，从好处来看，可以确保软件的质量不会出现大的问题，适合软件开发的大兵团运作，弊端来看，严重影响到软件的生产效率。&lt;/p&gt;
&lt;p&gt;从华为对测试角色的定位看，测试需要承担三种职能角色。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一种是管控角色。测试人员就像就像沙丁鱼箱中的鲶鱼一样，不断的通过各种数据，各流程，驱动上游团队持续的保持活跃，进行相关的改进。并且测试作为研发的一个环节，本身也要提供相关 TR 点的素材，配合提供项目的各类测试交付材料。在大型的团队中，这部分的流程和数据还是非常受到领导重视，因此也产生了很多华为自有测试员工，过于投入流程和数据，而忽略业务本身的现象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种角色是质量服务角色。就是测试要对产品投入实际的测试执行工作，发现版本的质量问题。在华为传统观念中，测试部应该对产品的质量负责，负责的重要标准就是测试部需要对版本进行一次完整测试，需要输出相关结论。在华为和开发和测试分工中，也是基于一种不信任的配合关系，测试人员不需要关注开发测试过程中已经验证了什么，版本转测试后，测试必须完整版本验证工作，从部门的角度给出最终的结论。而这种测试定位，在互联网领域中，已经逐步的弱化，只有关键的产品才会投入专职的测试专家进行测试设计和执行工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三种是工程能力角色，类似 Google 的工程生产力部门，定位为提升研发过程效率和质量，输出相关工具和方法的支撑，提升整个研发过程的测试效率。目前这部分的专家主要集中在 2012 实验室和几个大产品线的工具部。而产品测试（业务测试）投入的能力建设，主要集中在 DFX 的特性测试以及自动化能力方面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于华为传统的 To B 类产品，测试投入的 1、2 两个角色职能的工作非常多，也占用了业务测试团队的大量时间，特别对于具体的测试执行，各产品线业务测试投入大量合作员工进行基础的测试保障。对于工具和测试能力的提升，2012 实验室的测试行业投入较多，在 6+1 测试工具有了一些成果，但是能力和业务还是有一定的脱节，行业专家不会介入业务太深，业务定制化的测试需求也较多，导致很多实际的业务测试效率问题，仍然需要业务自身解决。&lt;/p&gt;
&lt;p&gt;我所在的云服务属于公司内少有的 To C 类产品。我们所有的产品都是无需向运营商交付的，对自有业务需求的控制比 To B 产品好太多，也可以在我们自有的环境上进行灰度发布，Beta 测试，很多快速交付的实践都在产品中落地，因此可以做到每月至少一次的迭代发布。&lt;/p&gt;
&lt;p&gt;但是对于云服务测试来讲，也仍然面临的较多的问题。我们的测试开发比在 1：7 到 1：10，基本上一个人负责一个或者多个模块的测试，在华为的质量体系下，我们也是要遵从华为一些质量交付件，例如云服务需要与 EMUI 进行版本的配套，相关的测试交付还是要参考 IPD 的流程，所以在流程工作的投入上，测试人员投入的仍然很多，各类的会议也是很多。安全交付件更是如此，这是公司的红线。在组织职责方面，测试和开发的组织职责也可以相对独立，不存在开发自测交付的概念，在版本交付后，所有的测试的工作需要测试部独立承担，包括外部采购的合作项目，可能开发需要投入一个 PM，但是测试要完成所有验收。未解决测试执行覆盖的问题，也是大量使用了合作员工，合作自有比也超过 5：1，合作的流失和培养一直都是历史难题。&lt;/p&gt;
&lt;p&gt;因为团队规模比较小，能力建设方面也主要采用合作的模式，依赖外部的测试能力和 2012 的团队，来推进云测， 6+1 等方面工作合作，测试的重点依然的是自动化，DFX 等方面。而对于业务体验等方面关注的力度并不足。交付类测试仍然是我们工作的主要方向。&lt;/p&gt;
&lt;h3&gt;业务测试人员的发展方向&lt;/h3&gt;
&lt;p&gt;虽然前面讲了很多测试的危机和问题，但是从行业发展的必要性来讲，测试是质量的重要保障，测试行业不可能被淘汰，我们只需要考虑如何让我们的行业价值更高，让自己不会被这个时代所抛弃。&lt;/p&gt;
&lt;p&gt;公司一直倡导的都是工匠精神，但是软件行业和传统的手艺不同，我们所使用的工具在不断的变化，十几年前，我们还在使用 Basic、Pascal，但是现在已经是 Java 的天下了，软件的工匠精神不是比拼的是对语言和工具的熟悉，更多的在于软件系统的经验。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;测试的定位，不是仅仅发现版本的问题，或者做简单测试技术工具的投入，而是应该定位更高一层，测试是整个产品的质量守护者，需要具备提前预防质量风险的能力，应该具备推进产品测试技术改进的能力，也应该具备产品研发过程中（含开发环节）测试效率提升的能力。测试能真正从客户角度去看待和发现问题，并推动客户质量满意度的不断提升。这个定位很高，实现过程也很难，我们现在普通的测试人员 80% 都是在测试的具体执行和一堆的事务性工作上，每日都在加班加点，很少有沉下心来分析问题的根因，通过学习不断寻找技术改进的方向。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从测试技术发展来看，测试的工具化或自动化肯定是未来的趋势，自动化的比例会不断的提升，但是机器的自动化短期内无法实现完全脱离测试人员的，仍然需要人工接入进行相关的自动化设计。从执行的特点看，测试分为两类，一类是固定场景的验证，一类是未知场景的探索。&lt;/p&gt;
&lt;p&gt;对于固定场景的验证，有预期的输入和输出，无论是接口测试还是 LLT （底层测试），都是具备这个特点。测试人员的重点是将具体的场景抽象为自动化用例，提升回归测试的工作效率。对于基于 UI 的自动化，因为产品可能存在较大变动，UI 识别也存在部分确定性，我们可以量力而行或尽可能抽象为接口自动化。在自动化工作中，测试要对开发有足够的可测试性要求，产品具备良好的代码解耦的架构。&lt;/p&gt;
&lt;p&gt;对于未知场景的探索，主要是针对没有对应测试设计的测试驱动。可以分为工具类的自动化探索，例如我们手机可靠性测试使用的 monkey，以及安全测试的 fuzzy 等。测试的场景由工具生成和决定。另外一种是人工的探索测试，这个概念近几年也比较盛行。但个人认为这种在可行性上还是有一定难度，对测试人员的经验要求较高，目前我们也并没有组织，主要通过 Beta 测试，引入大量普通用户完成各类场景的探索。&lt;/p&gt;
&lt;p&gt;任何测试都是不能 100% 发现问题，网上问题的发生也是很难避免，测试需要尽量降低网上问题的级别和发生概率，并且需要具备较高质量风险防范的意识，对于高风险产品必须有双重（或三重）的防范机制。例如我们做一个支付类产品，可能会在存在某些质量问题，导致用户未支付的情况下，支付状态进行了更新（这个例子可能大家感觉不会出现，但是现实中有各类可能）。测试人员必须对产品提出，有额外的管控系统，对账号进行准实时的核查比对，确保收支一致。互联网有过类似的安全，2012 年某东积分兑换 BUG 的问题轰动一时。好的测试专家需要像扁鹊大哥一样，尽可能的识别和规避可能的质量风险。&lt;/p&gt;
&lt;p&gt;测试人员的技能模型应该保持多样性的发展，在广度方面不断延伸，深度方面可以选择一两项技术进行不断挖掘。有三点需要测试重点关注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;编码能力：特别对于新员工，这个能力是与开发有共同语言的基础。测试人员需要了解对应业务的代码框架，构建工具，以及 LLT 测试，持续推动开发过程中的改进，能给予代码提出测试建议，将质量构建在开发阶段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组网能力：测试需要对系统的组网，以及实际的部署情况有清晰的技术理解，这样才能发现更多的质量问题和隐患。这个说起来是比较简单，但是如果做到深入的了解，还是有很高的技术难度，例如我们现在各个业务使用的 CDN 和 DNS，如何组网可以让我们的系统体验会更快更好。用户使用的 UC、QQ 浏览器等是具备缓存加速，在缓存场景下是否会对某些业务特性产生影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;业务能力：测试不能脱离业务，这也是为测试人员未来转型产品经理或其他岗位的一个必备能力。无论开发还是测试，能在整个职业生涯中，坚持到底的，是少之又少。大型产品线如有测试系统部之类的部门，如果脱离业务，纯粹投入技术规划或流程规划，往往会逐步被产品边缘化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;产品会有各类的隐患和问题，测试人员如果长期只发现简单的 BUG，不仅会让技能水平下降，而且会失去对工作的兴趣，我们只有通过工具或技术不断解决问题，才能挖掘测试工作的乐趣。&lt;/p&gt;
&lt;h3&gt;小编读后感&lt;/h3&gt;
&lt;p&gt;我想到了前一段读的一篇文章中提到《探索式软件测试》一书，作者 James Whittaker结合自己二十年的经验，从多个角度结合实例阐述了探索式软件测试的创新意识。他把测试职业发展的道路比喻为爬山，从初学者阶段到专家阶段之间存在着一个“测试的山峰”，人们需要通过一系列个人辅导、获取信息和接受常规指导来翻越山峰。成为一个测试初学者是很容易的，成为职业的测试人员也并不艰难，最难的是，如何翻越那座位于职业测试人员和测试专家之间的山峰。&lt;/p&gt;
&lt;p&gt;随着互联网的电商、金融等公司蓬勃发展，这些公司的技术团队的规模也快速增长，应用规模快速扩大，测试环境日益复杂，测试力量也在不断变化，应用验证成本不断提升，软件产品的质量含义也在变。在之前的专栏中，百度资深测试工程师永哥也和大家聊了聊“软件质量的变迁”（&lt;a href="http://mp.weixin.qq.com/s?__biz=MzA5NjcxMDU5MQ==&amp;amp;mid=2650045371&amp;amp;idx=2&amp;amp;sn=6603a4c58c3a012b0a981e0eb37c5464&amp;amp;scene=21#wechat_redirect"&gt;点击查看原文&lt;/a&gt;），他提到：&lt;/p&gt;
&lt;p&gt;永哥说：
    在不同发展阶段，移动互联网产品对质量的要求，对于QA测试团队的要求，会有不同。IT软件产品质量的好坏，最终是由用户可感知的真实体验决定的。用户体验好，产品服务稳定，几乎就是用户眼里的质量全部，决定了产品的用户认知。因此，QA工程师精力应投入在哪儿，根据产品发展不同时期，值得不断review，及时做出调整。所以，QA工程师和QA团队需要不断平衡程序bug、服务质量、产品品质三者关系，发挥QA懂业务场景、懂技术实现的特点，为用户代言，为产品品质代言，对产品的最终成功发挥保驾护航的作用。&lt;/p&gt;
&lt;p&gt;所以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;千万千万不要把自己只当成一个纯手工测试人员&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;千万千万不要把自己只当成“找到最多缺陷的人”，而是“找到最有意义缺陷的人”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;千万千万不要把自己只当成找bug的工程师，而是服务质量和产品品质的守护者&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;转自：http://qa.baidu.com/academy/detail/article/133#article-comment-wrap&lt;/p&gt;</summary><category term="测试"></category></entry><entry><title>测试分类</title><link href="http://king32783784.github.io/2017/03/10/%E6%B5%8B%E8%AF%95/" rel="alternate"></link><published>2017-03-10T00:00:00+08:00</published><updated>2017-03-10T00:00:00+08:00</updated><author><name>Others</name></author><id>tag:king32783784.github.io,2017-03-10:2017/03/10/测试/</id><summary type="html">&lt;p&gt;测试的方法有千千万万种，但以下几种是你必须深刻了解的：&lt;/p&gt;
&lt;h3&gt;功能测试（Function Testing）&lt;/h3&gt;
&lt;p&gt;功能测试就是对产品的各功能进行验证，根据功能测试用例，逐项测试，检查产品是否达到用户要求的功能。功能测试也叫黑盒测试或数据驱动测试，只需考虑需要测试的各个功能，不需要考虑整个软件的内部结构及代码.一般从软件产品的界面、架构出发，按照需求编写出来的测试用例，输入数据在预期结果和实际结果之间进行评测，进而提出更加使产品达到用户使用的要求。&lt;/p&gt;
&lt;p&gt;在小型移动开发团队中，这个环节一般由产品经理或开发自己负责，查看自己提的需求有没有被实现。比较大的团队会有正规测试人员进行这项工作。&lt;/p&gt;
&lt;h3&gt;单元测试（Unit Testing)&lt;/h3&gt;
&lt;p&gt;单元测试（模块测试）是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确。通常而言，一个单元测试是用于判断某个特定条件（或者场景）下某个特定函数的行为。
　
  单元测试是由程序员自己来完成，最终受益的也是程序员自己。可以这么说，程序员有责任编写功能代码，同时也就有责任为自己的代码编写单元测试。执行单元测试，就是为了证明这段代码的行为和我们期望的一致。&lt;/p&gt;
&lt;h3&gt;集成测试（IntegrationTesting）&lt;/h3&gt;
&lt;p&gt;集成测试，也叫组装测试或联合测试，是单元测试的逻辑扩展。在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。&lt;/p&gt;
&lt;p&gt;它最简单的形式是：把两个已经测试过的单元组合成一个组件，测试它们之间的接口。从这一层意义上讲，组件是指多个单元的集成聚合。在现实方案中，许多单元组合成组件，而这些组件又聚合为程序的更大部分。方法是测试片段的组合，并最终扩展成进程，将模块与其他组的模块一起测试。最后，将构成进程的所有模块一起测试。此外，如果程序由多个进程组成，应该成对测试它们，而不是同时测试所有进程。&lt;/p&gt;
&lt;h3&gt;内存泄漏测试（Memory LeakTesting)&lt;/h3&gt;
&lt;p&gt;内存泄漏也称作“存储渗漏”，用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。（其实说白了就是该内存空间使用完毕之后未回收）即所谓内存泄漏。
　
  内存泄漏形象的比喻是“操作系统可提供给所有进程的存储空间正在被某个进程榨干”，最终结果是程序运行时间越长，占用存储空间越来越多，最终用尽全部存储空间，整个系统崩溃。所以“内存泄漏”是从操作系统的角度来看的。这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。由程序申请的一块内存，如果没有任何一个指针指向它，那么这块内存就泄漏了。&lt;/p&gt;
&lt;h3&gt;回归测试（Regression Testing）&lt;/h3&gt;
&lt;p&gt;回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。自动回归测试将大幅降低系统测试、维护升级等阶段的成本。回归测试作为软件生命周期的一个组成部分，在整个软件测试过程中占有很大的工作量比重，软件开发的各个阶段都会进行多次回归测试。在渐进和快速迭代开发中，新版本的连续发布使回归测试进行的更加频繁，而在极端编程方法中，更是要求每天都进行若干次回归测试。因此，通过选择正确的回归测试策略来改进回归测试的效率和有效性是很有意义的。&lt;/p&gt;
&lt;h3&gt;Alpha测试&amp;amp;Beta测试&lt;/h3&gt;
&lt;p&gt;Alpha测试是用户在开发环境下的测试，或者是开发内部的用户在模拟实际环境下的测试；Beta测试是由软件的一个或多个用户在实际使用环境下进行的测试。
两者区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Alpha测试由开发人员或测试人员在场，可随时记录下错误和使用中出现的问题。&lt;/li&gt;
&lt;li&gt;Beta测试开发人员和测试人员都不在场。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，只有当α测试达到一定的可靠程度时，才能开始β测试。它处在整个测试的最后阶段。&lt;/p&gt;
&lt;h3&gt;软件压力测试（Software TestingPressure）&lt;/h3&gt;
&lt;p&gt;软件压力测试是一种基本的质量保证行为，它是每个重要软件测试工作的一部分。软件压力测试的基本思路很简单：不是在常规条件下运行手动或自动测试，而是在计算机数量较少或系统资源匮乏的条件下运行测试。通常要进行软件压力测试的资源包括内部内存、CPU 可用性、磁盘空间和网络带宽。&lt;/p&gt;
&lt;h3&gt;负载测试（Load Testing)&lt;/h3&gt;
&lt;p&gt;通过测试系统在资源超负荷情况下的表现，以发现设计上的错误或验证系统的负载能力。在这种测试中，将使测试对象承担不同的工作量，以评测和评估测试对象在不同工作量条件下的性能行为，以及持续正常运行的能力。负载测试的目标是确定并确保系统在超出最大预期工作量的情况下仍能正常运行。此外，负载测试还要评估性能特征。例如，响应时间、事务处理速率和其他与时间相关的方面。&lt;/p&gt;
&lt;h3&gt;性能测试（PerformanceTesting）&lt;/h3&gt;
&lt;p&gt;性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。负载测试和压力测试都属于性能测试，两者可以结合进行。通过负载测试，确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。压力测试是通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试。&lt;/p&gt;
&lt;h3&gt;验收测试（Acceptance Testing）&lt;/h3&gt;
&lt;p&gt;验收测试是部署软件之前的最后一个测试操作。在软件产品完成了单元测试、集成测试和系统测试等之后，产品发布之前所进行的软件测试活动。它是技术测试的最后一个阶段，也称为交付测试。验收测试的目的是确保软件准备就绪，并且可以让最终用户将其用于执行软件的既定功能和任务。经集成测试后，已经按照设计把所有的模块组装成一个完整的软件系统，接口错误也已经基本排除了，接着就应该进一步验证软件的有效性，这就是验收测试的任务，即软件的功能和性能如同用户所合理期待的那样。
  工程及其他相关领域中，验收测试是指确认一系统是否符合设计规格或契约之需求内容的测试，可能会包括化学测试、物理测试或是性能测试。在系统工程中验收测试可能包括在系统（例如一套软件系统、许多机械零件或是一批化学制品）交付前的黑箱测试。软件开发者常会将系统开发者进行的验收测试和客户在接受产品前进行的验收测试分开。后者一般会称为使用者验收测试、终端客户测试、实机（验收）测试、现场（验收）测试。在进行主要测试程序之前，常用冒烟测试作为一个此阶段的验收测试。&lt;/p&gt;
&lt;p&gt;转自：http://qa.baidu.com/academy/detail/article/141&lt;/p&gt;</summary><category term="测试"></category></entry><entry><title>北京折叠－郝景芳</title><link href="http://king32783784.github.io/2016/09/01/bei-jing-zhe-die-hao-jing-fang/" rel="alternate"></link><published>2016-09-01T00:00:00+08:00</published><updated>2016-09-01T00:00:00+08:00</updated><author><name>others</name></author><id>tag:king32783784.github.io,2016-09-01:2016/09/01/bei-jing-zhe-die-hao-jing-fang/</id><summary type="html">&lt;h2&gt;第一幕&lt;/h2&gt;
&lt;p&gt;&lt;img src="https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/W3UPOU6IG2.jpg" height="280" width="420"&gt;&lt;/p&gt;
&lt;p&gt;清晨4:50，老刀穿过熙熙攘攘的步行街，去找彭蠡。&lt;/p&gt;
&lt;p&gt;从垃圾站下班之后，老刀回家洗了个澡，换了衣服。白色衬衫和褐色裤子，这是他唯一一套体面衣服，衬衫袖口磨了边，他把袖子卷到胳膊肘。老刀四十八岁，没结婚，已经过了注意外表的年龄，又没人照顾起居，这一套衣服留着穿了很多年，每次穿一天，回家就脱了叠上。他在垃圾站上班，没必要穿得体面，偶尔参加谁家小孩的婚礼，才拿出来穿在身上。这一次他不想脏兮兮地见陌生人。他在垃圾站连续工作了五小时，很担心身上会有味道。&lt;/p&gt;
&lt;p&gt;步行街上挤满了刚刚下班的人。拥挤的男人女人围着小摊子挑土特产，大声讨价还价。食客围着塑料桌子，埋头在酸辣粉的热气腾腾中，饿虎扑食一般，白色蒸汽遮住了脸。油炸的香味弥漫。货摊上的酸枣和核桃堆成山，腊肉在头顶摇摆。这个点是全天最热闹的时间，基本都收工了，忙碌了几个小时的人们都赶过来吃一顿饱饭，人声鼎沸。&lt;/p&gt;
&lt;p&gt;老刀艰难地穿过人群。端盘子的伙计一边喊着让让一边推开挡道的人，开出一条路来，老刀跟在后面。&lt;/p&gt;
&lt;p&gt;彭蠡家在小街深处。老刀上楼，彭蠡不在家。问邻居，邻居说他每天快到关门才回来，具体几点不清楚。&lt;/p&gt;
&lt;p&gt;老刀有点担忧，看了看手表，清晨5点。&lt;/p&gt;
&lt;p&gt;他回到楼门口等着。两旁狼吞虎咽的饥饿少年围绕着他。他认识其中两个，原来在彭蠡家见过一两次。少年每人面前摆着一盘炒面或炒粉，几个人分吃两个菜，盘子里一片狼藉，筷子扔在无望而锲而不舍地拨动，寻找辣椒丛中的肉星。老刀又下意识闻了闻小臂，不知道身上还有没有垃圾的腥味。周围的一切嘈杂而庸常，和每个清晨一样。&lt;/p&gt;
&lt;p&gt;“哎，你们知道那儿一盘回锅肉多少钱吗？”那个叫小李的少年说。&lt;/p&gt;
&lt;p&gt;“靠，菜里有沙子。”另外一个叫小丁的胖少年突然捂住嘴说，他的指甲里还带着黑泥， “坑人啊。得找老板退钱！”&lt;/p&gt;
&lt;p&gt;“人家那儿一盘回锅肉，就三百四。”小李说，“三百四！一盘水煮牛肉四百二呢。”&lt;/p&gt;
&lt;p&gt;“什么玩意？这么贵。”小丁捂着腮帮子咕哝道。&lt;/p&gt;
&lt;p&gt;另外两个少年对谈话没兴趣，还在埋头吃面，小李低头看着他们，眼睛似乎穿过他们，看到了某个看不见的地方，目光里有热切。&lt;/p&gt;
&lt;p&gt;老刀的肚子也感觉到饥饿。他迅速转开眼睛，可是来不及了，那种感觉迅速席卷了他，胃的空虚像是一个深渊，让他身体微微发颤。他有一个月不吃清晨这顿饭了。一顿饭差不多一百块，一个月三千块，攒上一年就够糖糖两个月的幼儿园开销了。&lt;/p&gt;
&lt;p&gt;他向远处看，城市清理队的车辆已经缓缓开过来了。&lt;/p&gt;
&lt;p&gt;他开始做准备，若彭蠡一时再不回来，他就要考虑自己行动了。虽然会带来不少困难，但时间不等人，总得走才行。身边卖大枣的女人高声叫卖，不时打断他的思绪，声音的洪亮刺得他头疼。步行街一端的小摊子开始收拾，人群像用棍子搅动的池塘里的鱼，倏一下散去。没人会在这时候和清理队较劲。小摊子收拾得比较慢，清理队的车耐心地移动。步行街通常只是步行街，但对清理队的车除外。谁若走得慢了，就被强行收拢起来。&lt;/p&gt;
&lt;p&gt;这时彭蠡出现了。他剔着牙，敞着衬衫的扣子，不紧不慢地踱回来，不时打饱嗝。彭蠡六十多了，变得懒散不修边幅，两颊像沙皮狗一样耷拉着，让嘴角显得总是不满意地撇着。如果只看这幅模样，不知道他年轻时的样子，会以为他只是个胸无大志只知道吃喝的怂包。但从老刀很小的时候，他就听父亲讲过彭蠡的事。&lt;/p&gt;
&lt;p&gt;老刀迎上前去。彭蠡看到他要打招呼，老刀却打断他：“我没时间和你解释。我需要去第一空间，你告诉我怎么走。”&lt;/p&gt;
&lt;p&gt;彭蠡愣住了，已经有十年没人跟他提过第一空间的事，他的牙签捏在手里，不知不觉掰断了。他有片刻没回答，见老刀实在有点急了，才拽着他向楼里走。“回我家说，”彭蠡说，“要走也从那儿走。”&lt;/p&gt;
&lt;p&gt;在他们身后，清理队已经缓缓开了过来，像秋风扫落叶一样将人们扫回家。“回家啦，回家啦。转换马上开始了。”车上有人吆喝着。&lt;/p&gt;
&lt;p&gt;彭蠡带老刀上楼，进屋。他的单人小房子和一般公租屋无异，六平米房间，一个厕所，一个能做菜的角落，一张桌子一把椅子，胶囊床铺，胶囊下是抽拉式箱柜，可以放衣服物品。墙面上有水渍和鞋印，没做任何修饰，只是歪斜着贴了几个挂钩，挂着夹克和裤子。进屋后，彭蠡把墙上的衣服毛巾都取下来，塞到最靠边的抽屉里。转换的时候，什么都不能挂出来。老刀以前也住这样的单人公租房。一进屋，他就感到一股旧日的气息。&lt;/p&gt;
&lt;p&gt;彭蠡直截了当地瞪着老刀：“你不告诉我为什么，我就不告诉你怎么走。” &lt;/p&gt;
&lt;p&gt;已经5点半了，还有半个小时。&lt;/p&gt;
&lt;p&gt;老刀简单讲了事情的始末。从他捡到纸条瓶子，到他偷偷躲入垃圾道，到他在第二空间接到的委托，再到他的行动。他没有时间描述太多，最好马上就走。&lt;/p&gt;
&lt;p&gt;“你躲在垃圾道里？去第二空间？”彭蠡皱着眉，“那你得等24小时啊。”&lt;/p&gt;
&lt;p&gt;“二十万块。”老刀说，“等一礼拜也值啊。”&lt;/p&gt;
&lt;p&gt;“你就这么缺钱花？”&lt;/p&gt;
&lt;p&gt;老刀沉默了一下。“糖糖还有一年多该去幼儿园了。”他说，“我来不及了。”&lt;/p&gt;
&lt;p&gt;老刀去幼儿园咨询的时候，着实被吓到了。稍微好一点的幼儿园招生前两天，就有家长带着铺盖卷在幼儿园门口排队，两个家长轮着，一个吃喝拉撒，另一个坐在幼儿园门口等。就这么等上四十多个小时，还不一定能排进去。前面的名额早用钱买断了，只有最后剩下的寥寥几个名额分给苦熬排队的爹妈。这只是一般不错的幼儿园，更好一点的连排队都不行，从一开始就是钱买机会。老刀本来没什么奢望，可是自从糖糖一岁半之后，就特别喜欢音乐，每次在外面听见音乐，她就小脸放光，跟着扭动身子手舞足蹈。那个时候她特别好看。老刀对此毫无抵抗力，他就像被舞台上的灯光层层围绕着，只看到一片耀眼。无论付出什么代价，他都想送糖糖去一个能教音乐和跳舞的幼儿园。&lt;/p&gt;
&lt;p&gt;彭蠡脱下外衣，一边洗脸，一边和老刀说话。说是洗脸，不过只是用水随便抹一抹。水马上就要停了，水流已经变得很小。彭蠡从墙上拽下一条脏兮兮的毛巾，随意蹭了蹭，又将毛巾塞进抽屉。他湿漉漉的头发显出油腻的光泽。&lt;/p&gt;
&lt;p&gt;“你真是作死，”彭蠡说，“她又不是你闺女，犯得着吗。”&lt;/p&gt;
&lt;p&gt;“别说这些了。快告我怎么走。”老刀说。&lt;/p&gt;
&lt;p&gt;彭蠡叹了口气：“你可得知道，万一被抓着，可不只是罚款，得关上好几个月。”&lt;/p&gt;
&lt;p&gt;“你不是去过好多次吗？”&lt;/p&gt;
&lt;p&gt;“只有四次。第五次就被抓了。”&lt;/p&gt;
&lt;p&gt;“那也够了。我要是能去四次，抓一次也无所谓。”&lt;/p&gt;
&lt;p&gt;老刀要去第一空间送一样东西，送到了挣十万块，带来回信挣二十万。这不过是冒违规的大不韪，只要路径和方法对，被抓住的几率并不大，挣的却是实实在在的钞票。他不知道有什么理由拒绝。他知道彭蠡年轻的时候为了几笔风险钱，曾经偷偷进入第一空间好几次，贩卖私酒和烟。他知道这条路能走。&lt;/p&gt;
&lt;p&gt;5:45。他必须马上走了。&lt;/p&gt;
&lt;p&gt;彭蠡又叹口气，知道劝也没用。他已经上了年纪，对事懒散倦怠了，但他明白，自己在五十岁前也会和老刀一样。那时他不在乎坐牢之类的事。不过是熬几个月出来，挨两顿打，但挣的钱是实实在在的。只要抵死不说钱的下落，最后总能过去。秩序局的条子也不过就是例行公事。他把老刀带到窗口，向下指向一条被阴影覆盖的小路。&lt;/p&gt;
&lt;p&gt;“从我房子底下爬下去，顺着排水管，毡布底下有我原来安上去的脚蹬，身子贴得足够紧了就能避开摄像头。从那儿过去，沿着阴影爬到边上。你能摸着也能看见那道缝。沿着缝往北走。一定得往北。千万别错了。”&lt;/p&gt;
&lt;p&gt;彭蠡接着解释了爬过土地的诀窍。要借着升起的势头，从升高的一侧沿截面爬过五十米，到另一侧地面，爬上去，然后向东，那里会有一丛灌木，在土地合拢的时候可以抓住并隐藏自己。老刀没有听完，就已经将身子探出窗口，准备向下爬了。&lt;/p&gt;
&lt;p&gt;彭蠡帮老刀爬出窗子，扶着他踩稳了窗下的踏脚。彭蠡突然停下来。“说句不好听的，”他说，“我还是劝你最好别去。那边可不是什么好地儿，去了之后没别的，只能感觉自己的日子有多操蛋。没劲。”&lt;/p&gt;
&lt;p&gt;老刀的脚正在向下试探，身子还扒着窗台。“没事。”他说得有点费劲，“我不去也知道自己的日子有多操蛋。”&lt;/p&gt;
&lt;p&gt;“好自为之吧。”彭蠡最后说。&lt;/p&gt;
&lt;p&gt;老刀顺着彭蠡指出的路径快速向下爬。脚蹬的位置非常舒服。他看到彭蠡在窗口的身影，点了根烟，非常大口地快速抽了几口，又掐了。彭蠡一度从窗口探出身子，似乎想说什么，但最终还是缩了回去。窗子关上了，发着幽幽的光。老刀知道，彭蠡会在转换前最后一分钟钻进胶囊，和整个城市数千万人一样，受胶囊定时释放出的气体催眠，陷入深深睡眠，身子随着世界颠倒来去，头脑却一无所知，一睡就是整整40个小时，到次日晚上再睁开眼睛。彭蠡已经老了，他终于和这个世界其他五千万人一样了。&lt;/p&gt;
&lt;p&gt;老刀用自己最快的速度向下，一蹦一跳，在离地足够近的时候纵身一跃，匍匐在地上。彭蠡的房子在四层，离地不远。爬起身，沿高楼在湖边投下的阴影奔跑。他能看到草地上的裂隙，那是翻转的地方。还没跑到，就听到身后在压抑中轰鸣的隆隆和偶尔清脆的嘎啦声。老刀转过头，高楼拦腰截断，上半截正从天上倒下，缓慢却不容置疑地压迫过来。&lt;/p&gt;
&lt;p&gt;老刀被震住了，怔怔看了好一会儿。他跑到缝隙，伏在地上。&lt;/p&gt;
&lt;p&gt;转换开始了。这是24小时周期的分隔时刻。整个世界开始翻转。钢筋砖块合拢的声音连成一片，像出了故障的流水线。高楼收拢合并，折叠成立方体。霓虹灯、店铺招牌、阳台和附加结构都被吸收入墙体，贴成楼的肌肤。结构见缝插针，每一寸空间都被占满。&lt;/p&gt;
&lt;p&gt;大地在升起。老刀观察着地面的走势，来到缝的边缘，又随着缝隙的升起不断向上爬。他手脚并用，从大理石铺就的地面边缘起始，沿着泥土的截面，抓住土里埋藏的金属断茬，最初是向下，用脚试探着退行，很快，随着整快土地的翻转，他被带到空中。&lt;/p&gt;
&lt;p&gt;老刀想到前一天晚上城市的样子。&lt;/p&gt;
&lt;p&gt;当时他从垃圾堆中抬起眼睛，警觉地听着门外的声音。周围发酵腐烂的垃圾散发出刺鼻的气息，带一股发腥的甜腻味。他倚在门前。铁门外的世界在苏醒。&lt;/p&gt;
&lt;p&gt;当铁门掀开的缝隙透入第一道街灯的黄色光芒，他俯下身去，从缓缓扩大的缝隙中钻出。街上空无一人，高楼灯光逐层亮起，附加结构从楼两侧探出，向两旁一节一节伸展，门廊从楼体内延伸，房檐延轴旋转，缓缓落下，楼梯降落延伸到马迷途上。步行街的两侧，一个又一个黑色立方体从中间断裂，向两侧打开，露出其中货架的结构。立方体顶端伸出招牌，连成商铺的走廊，两侧的塑料棚向头顶延伸闭合。街道空旷得如同梦境。&lt;/p&gt;
&lt;p&gt;霓虹灯亮了，商铺顶端闪烁的小灯打出新疆大枣、东北拉皮、上海烤麸和湖南腊肉。&lt;/p&gt;
&lt;p&gt;整整一天，老刀头脑中都忘不了这一幕。他在这里生活了四十八年，还从来没有见过这一切。他的日子总是从胶囊起，至胶囊终，在脏兮兮的餐桌和被争吵萦绕的货摊之间穿行。这是他第一次看到世界纯粹的模样。&lt;/p&gt;
&lt;p&gt;每个清晨，如果有人从远处观望——就像大货车司机在高速北京入口处等待时那样——他会看到整座城市的伸展与折叠。&lt;/p&gt;
&lt;p&gt;清晨六点，司机们总会走下车，站在高速边上，揉着经过一夜潦草睡眠而昏沉的眼睛，打着哈欠，相互指点着望向远处的城市中央。高速截断在七环之外，所有的翻转都在六环内发生。不远不近的距离，就像遥望西山或是海上的一座孤岛。&lt;/p&gt;
&lt;p&gt;晨光熹微中，一座城市折叠自身，向地面收拢。高楼像最卑微的仆人，弯下腰，让自己低声下气切断身体，头碰着脚，紧紧贴在一起，然后再次断裂弯腰，将头顶手臂扭曲弯折，插入空隙。高楼弯折之后重新组合，蜷缩成致密的巨大魔方，密密匝匝地聚合到一起，陷入沉睡。然后地面翻转，小块小块土地围绕其轴，一百八十度翻转到另一面，将另一面的建筑楼宇露出地表。楼宇由折叠中站立起身，在灰蓝色的天空中像苏醒的兽类。城市孤岛在橘黄色晨光中落位，展开，站定，腾起弥漫的灰色苍云。&lt;/p&gt;
&lt;p&gt;司机们就在困倦与饥饿中欣赏这一幕无穷循环的城市戏剧。&lt;/p&gt;
&lt;h2&gt;第二幕&lt;/h2&gt;
&lt;p&gt;折叠城市分三层空间。大地的一面是第一空间，五百万人口，生存时间是从清晨六点到第二天清晨六点。空间休眠，大地翻转。翻转后的另一面是第二空间和第三空间。第二空间生活着两千五百万人口，从次日清晨六点到夜晚十点，第三空间生活着五千万人，从十点到清晨六点，然后回到第一空间。时间经过了精心规划和最优分配，小心翼翼隔离，五百万人享用二十四小时，七千五百万人享用另外二十四小时。&lt;/p&gt;
&lt;p&gt;大地的两侧重量并不均衡，为了平衡这种不均，第一空间的土地更厚，土壤里埋藏配重物质。人口和建筑的失衡用土地来换。第一空间居民也因而认为自身的底蕴更厚。&lt;/p&gt;
&lt;p&gt;老刀从小生活在第三空间。他知道自己的日子是什么样，不用彭蠡说他也知道。他是个垃圾工，做了二十八年垃圾工，在可预见的未来还将一直做下去。他还没找到可以独自生存的意义和最后的怀疑主义。他仍然在卑微生活的间隙占据一席。&lt;/p&gt;
&lt;p&gt;老刀生在北京城，父亲就是垃圾工。据父亲说，他出生的时候父亲刚好找到这份工作，为此庆贺了整整三天。父亲本是建筑工，和数千万其他建筑工一样，从四方涌到北京寻工作，这座折叠城市就是父亲和其他人一起亲手建的。一个区一个区改造旧城市，像白蚁漫过木屋一样啃噬昔日的屋檐门槛，再把土地翻起，建筑全新的楼宇。他们埋头斧凿，用累累砖块将自己包围在中间，抬起头来也看不见天空，沙尘遮挡视线，他们不知晓自己建起的是怎样的恢弘。直到建成的日子高楼如活人一般站立而起，他们才像惊呆了一样四处奔逃，仿佛自己生下了一个怪胎。奔逃之后，镇静下来，又意识到未来生存在这样的城市会是怎样一种殊荣，便继续辛苦摩擦手脚，低眉顺眼勤恳，寻找各种存留下来的机会。据说城市建成的时候，有八千万想要寻找工作留下来的建筑工，最后能留下来的，不过两千万。&lt;/p&gt;
&lt;p&gt;垃圾站的工作能找到也不容易，虽然只是垃圾分类处理，但还是层层筛选，要有力气有技巧，能分辨能整理，不怕辛苦不怕恶臭，不对环境挑三拣四。老刀的父亲靠强健的意志在汹涌的人流中抓住机会的细草，待人潮退去，留在干涸的沙滩上，抓住工作机会，低头俯身，艰难浸在人海和垃圾混合的酸朽气味中，一干就是二十年。他既是这座城市的建造者，也是城市的居住者和分解者。&lt;/p&gt;
&lt;p&gt;老刀出生时，折叠城市才建好两年，他从来没去过其他地方，也没想过要去其他地方。他上了小学、中学。考了三年大学，没考上，最后还是做了垃圾工。他每天上五个小时班，从夜晚十一点到清晨四点，在垃圾站和数万同事一起，快速而机械地用双手处理废物垃圾，将第一空间和第二空间传来的生活碎屑转化为可利用的分类的材质，再丢入再处理的熔炉。他每天面对垃圾传送带上如溪水涌出的残渣碎片，从塑料碗里抠去吃剩的菜叶，将破碎酒瓶拎出，把带血的卫生巾后面未受污染的一层薄膜撕下，丢入可回收的带着绿色条纹的圆筒。他们就这么干着，以速度换生命，以数量换取薄如蝉翼的仅有的奖金。&lt;/p&gt;
&lt;p&gt;第三空间有两千万垃圾工，他们是夜晚的主人。另三千万人靠贩卖衣服食物燃料和保险过活，但绝大多数人心知肚明，垃圾工才是第三空间繁荣的支柱。每每在繁花似锦的霓虹灯下漫步，老刀就觉得头顶都是食物残渣构成的彩虹。这种感觉他没法和人交流，年轻一代不喜欢做垃圾工，他们千方百计在舞厅里表现自己，希望能找到一个打碟或伴舞的工作。在服装店做一个店员也是好的选择，手指只拂过轻巧衣物，不必在泛着酸味的腐烂物中寻找塑料和金属。少年们已经不那么恐惧生存，他们更在意外表。&lt;/p&gt;
&lt;p&gt;老刀并不嫌弃自己的工作，但他去第二空间的时候，非常害怕被人嫌弃。&lt;/p&gt;
&lt;p&gt;那是前一天清晨的事。他捏着小纸条，偷偷从垃圾道里爬出，按地址找到写纸条的人。第二空间和第三空间的距离没那么远，它们都在大地的同一面，只是不同时间出没。转换时，一个空间高楼折起，收回地面，另一个空间高楼从地面中节节升高，踩着前一个空间的楼顶作为地面。唯一的差别是楼的密度。他在垃圾道里躲了一昼夜才等到空间敞开。他第一次到第二空间，并不紧张，唯一担心的是身上腐坏的气味。&lt;/p&gt;
&lt;p&gt;所幸秦天是宽容大度的人。也许他早已想到自己将招来什么样的人，当小纸条放入瓶中的时候，他就知道自己将面对的是谁。&lt;/p&gt;
&lt;p&gt;秦天很和气，一眼就明白老刀前来的目的，将他拉入房中，给他热水洗澡，还给他一件浴袍换上。“我只有依靠你了。”秦天说。&lt;/p&gt;
&lt;p&gt;秦天是研究生，住学生公寓。一个公寓四个房间，四个人一人一间，一个厨房两个厕所。老刀从来没在这么大的厕所洗过澡。他很想多洗一会儿，将身上气味好好冲一冲，但又担心将澡盆弄脏，不敢用力搓动。墙上喷出泡沫的时候他吓了一跳，热蒸汽烘干也让他不适应。洗完澡，他拿起秦天递过来的浴袍，犹豫了很久才穿上。他把自己的衣服洗了，又洗了厕所盆里随意扔着的几件衣服。生意是生意，他不想欠人情。&lt;/p&gt;
&lt;p&gt;秦天要送礼物给他相好的女孩子。他们在工作中认识，当时秦天有机会去第一空间实习，联合国经济司，她也在那边实习。只可惜只有一个月，回来就没法再去了。他说她生在第一空间，家教严格，父亲不让她交往第二空间的男孩，所以不敢用官方通道寄给她。他对未来充满乐观，等他毕业就去申请联合国新青年项目，如果能入选，就也能去第一空间工作。他现在研一，还有一年毕业。他心急如焚，想她想得发疯。他给她做了一个项链坠，能发光的材质，透明的，玫瑰花造型，作为他的求婚信物。&lt;/p&gt;
&lt;p&gt;“我当时是在一个专题研讨会，就是上回讨论联合国国债那个会，你应该听说过吧？就是那个……anyway，我当时一看，啊……立刻跑过去跟她说话，她给嘉宾引导座位，我也不知道应该说点什么，就在她身后走过来又走过去。最后我假装要找同传，让她带我去找。她特温柔，说话细声细气的。我压根就没追过姑娘，特别紧张，……后来我们俩好了之后有一次说起这件事……你笑什么？……对，我们是好了。……还没到那种关系，就是……不过我亲过她了。”秦天也笑了，有点不好意思，“是真的。你不信吗？是。连我自己也不信。你说她会喜欢我吗？”&lt;/p&gt;
&lt;p&gt;“我不知道啊。”老刀说，“我又没见过她。”&lt;/p&gt;
&lt;p&gt;这时，秦天同屋的一个男生凑过来，笑道：“大叔，您这么认真干吗？这家伙哪是问你，他就是想听人说‘你这么帅，她当然会喜欢你’。”&lt;/p&gt;
&lt;p&gt;“她很漂亮吧？”&lt;/p&gt;
&lt;p&gt;“我跟你说也不怕你笑话。”秦天在屋里走来走去，“你见到她就知道什么叫清雅绝伦。”&lt;/p&gt;
&lt;p&gt;秦天突然顿住了，不说了，陷入回忆。他想起依言的嘴，他最喜欢的就是她的嘴，那么小小的，莹润的，下嘴唇饱满，带着天然的粉红色，让人看着看着就忍不住想咬一口。她的脖子也让他动心，虽然有时瘦得露出筋，但线条是纤直而好看的，皮肤又白又细致，从脖子一直延伸到衬衫里，让人的视线忍不住停在衬衫的第二个扣子那里。他第一次轻吻她一下，她躲开，他又吻，最后她退无可退，就把眼睛闭上了，像任人宰割的囚犯，引他一阵怜惜。她的唇很软，他用手反复感受她腰和臀部的曲线。从那天开始，他就居住在思念中。她是他夜晚的梦境，是他抖动自己时看到的光芒。&lt;/p&gt;
&lt;p&gt;秦天的同学叫张显，和老刀开始聊天，聊得很欢。&lt;/p&gt;
&lt;p&gt;张显问老刀第三空间的生活如何，又说他自己也想去第三空间住一段。他听人说，如果将来想往上爬，有过第三空间的管理经验是很有用的。现在几个当红的人物，当初都是先到第三空间做管理者，然后才升到第一空间，若是停留在第二空间，就什么前途都没有，就算当个行政干部，一辈子级别也高不了。他将来想要进政府，已经想好了路。不过他说他现在想先挣两年钱再说，去银行来钱快。他见老刀的反应很迟钝，几乎不置可否，以为老刀厌恶这条路，就忙不迭地又加了几句解释。&lt;/p&gt;
&lt;p&gt;“现在政府太混沌了，做事太慢，僵化，体系也改不动。”他说，“等我将来有了机会，我就推快速工作作风改革。干得不行就滚蛋。”他看老刀还是没说话，又说，“选拔也要放开。也向第三空间放开。”&lt;/p&gt;
&lt;p&gt;老刀没回答。他其实不是厌恶，只是不大相信。&lt;/p&gt;
&lt;p&gt;张显一边跟老刀聊天，一边对着镜子打领带，喷发胶。他已经穿好了衬衫，浅蓝色条纹，亮蓝色领带。喷发胶的时候一边闭着眼睛皱着眉毛避开喷雾，一边吹口哨。&lt;/p&gt;
&lt;p&gt;张显夹着包走了，去银行实习上班。秦天说着话也要走。他还有课，要上到下午四点。临走前，他当着老刀的面把五万块定金从网上转到老刀卡里，说好了剩下的钱等他送到再付。老刀问他这笔钱是不是攒了很久，看他是学生，如果拮据，少要一点也可以。秦天说没事，他现在实习，给金融咨询公司打工，一个月十万块差不多。这也就是两个月工资，还出得起。老刀一个月一万块标准工资，他看到差距，但他没有说。秦天要老刀务必带回信回来，老刀说试试。秦天给老刀指了吃喝的所在，叫他安心在房间里等转换。&lt;/p&gt;
&lt;p&gt;老刀从窗口看向街道。他很不适应窗外的日光。太阳居然是淡白色，不是黄色。日光下的街道也显得宽阔，老刀不知道是不是错觉，这街道看上去有第三空间的两倍宽。楼并不高，比第三空间矮很多。路上的人很多，匆匆忙忙都在急着赶路，不时有人小跑着想穿过人群，前面的人就也加起速，穿过路口的时候，所有人都像是小跑着。大多数人穿得整齐，男孩子穿西装，女孩子穿衬衫和短裙，脖子上围巾低垂，手里拎着线条硬朗的小包，看上去精干。街上汽车很多，在路口等待的时候，不时有看车的人从车窗伸出头，焦急地向前张望。老刀很少见到这么多车，他平时习惯了磁悬浮，挤满人的车厢从身边加速，呼一阵风。&lt;/p&gt;
&lt;p&gt;中午十二点的时候，走廊里一阵声响。老刀从门上的小窗向外看。楼道地面化为传送带开始滚动，将各屋门口的垃圾袋推入尽头的垃圾道。楼道里腾起雾，化为密实的肥皂泡沫，飘飘忽忽地沉降，然后是一阵水，水过了又一阵热蒸汽。&lt;/p&gt;
&lt;p&gt;背后突然有声音，吓了老刀一跳。他转过身，发现公寓里还有一个男生，刚从自己房间里出来。男生面无表情，看到老刀也没有打招呼。他走到阳台旁边一台机器旁边，点了点，机器里传出咔咔刷刷轰轰嚓的声音，一阵香味飘来，男生端出一盘菜又回了房间。从他半开的门缝看过去，男孩坐在地上的被子和袜子中间，瞪着空无一物的墙，一边吃一边咯咯地笑。他不时用手推一推眼镜。吃完把盘子放在脚边，站起身，同样对着空墙做击打动作，费力气顶住某个透明的影子，偶尔来一个背摔，气喘吁吁。&lt;/p&gt;
&lt;p&gt;老刀对第二空间最后的记忆是街上撤退时的优雅。从公寓楼的窗口望下去，一切都带着令人羡慕的秩序感。九点十五分开始，街上一间间卖衣服的小店开始关灯，聚餐之后的团体面色红润，相互告别。年轻男女在出租车外亲吻。然后所有人回楼，世界蛰伏。&lt;/p&gt;
&lt;p&gt;夜晚十点到了。他回到他的世界，回去上班。&lt;/p&gt;
&lt;h2&gt;第三幕&lt;/h2&gt;
&lt;p&gt;第一和第三空间之间没有连通的垃圾道，第一空间的垃圾经过一道铁闸，运到第三空间之后，铁闸迅速合拢。老刀不喜欢从地表翻越，但他没有办法。&lt;/p&gt;
&lt;p&gt;他在呼啸的风中爬过翻转的土地，抓住每一寸零落的金属残渣，找到身体和心理平衡，最后匍匐在离他最遥远的一重世界的土地上。他被整个攀爬弄得头晕脑胀，胃口也不舒服。他忍住呕吐，在地上趴了一会儿。&lt;/p&gt;
&lt;p&gt;当他爬起身的时候，天亮了。&lt;/p&gt;
&lt;p&gt;老刀从来没有见过这样的景象。太阳缓缓升起，天边是深远而纯净的蓝，蓝色下沿是橙黄色，有斜向上的条状薄云。太阳被一处屋檐遮住，屋檐显得异常黑，屋檐背后明亮夺目。太阳升起时，天的蓝色变浅了，但是更宁静透彻。老刀站起身，向太阳的方向奔跑。他想要抓住那道褪去的金色。蓝天中能看见树枝的剪影。他的心狂跳不已。他从来不知道太阳升起竟然如此动人。&lt;/p&gt;
&lt;p&gt;他跑了一段路，停下来，冷静了。他站在街道中央。路的两旁是高大树木和大片草坪。他环视四周，目力所及，远远近近都没有一座高楼。他迷惑了，不确定自己是不是真的到了第一空间。他能看见两排粗壮的银杏。&lt;/p&gt;
&lt;p&gt;他又退回几步，看着自己跑来的方向。街边有一个路牌。他打开手机里存的地图，虽然没有第一空间动态图权限，但有事先下载的静态图。他找到了自己的位置和他要去的地方。他刚从一座巨大的园子里奔出来，翻转的地方就在园子的湖边。&lt;/p&gt;
&lt;p&gt;老刀在万籁俱寂的街上跑了一公里，很容易找到了要找的小区。他躲在一丛灌木背后，远远地望着那座漂亮的房子。&lt;/p&gt;
&lt;p&gt;8:30，依言出来了。&lt;/p&gt;
&lt;p&gt;她像秦天描述的一样清秀，只是没有那么漂亮。老刀早就能想到这点。不会有任何女孩长得像秦天描述的那么漂亮。他明白了为什么秦天着重讲她的嘴。她的眼睛和鼻子很普通，只是比较秀气，没什么好讲的。她的身材还不错，骨架比较小，虽然高，但看上去很纤细。穿了一条乳白色连衣裙，有飘逸的裙摆，腰带上有珍珠，黑色高跟皮鞋。&lt;/p&gt;
&lt;p&gt;老刀悄悄走上前去。为了不吓到她，他特意从正面走过去，离得远远的就鞠了一躬。&lt;/p&gt;
&lt;p&gt;她站住了，惊讶地看着他。&lt;/p&gt;
&lt;p&gt;老刀走近了，说明来意，将包裹着情书和项链坠的信封从怀里掏出来。&lt;/p&gt;
&lt;p&gt;她的脸上滑过一丝惊慌，小声说：“你先走，我现在不能和你说。”&lt;/p&gt;
&lt;p&gt;“呃……我其实没什么要说的，”老刀说，“我只是送信的。”&lt;/p&gt;
&lt;p&gt;她不接，双手紧紧地搅握着，只是说：“我现在不能收。你先走。我是说真的，拜托了，你先走吧好吗？”她说着低头，从包里掏出一张名片，“中午到这里找我。”&lt;/p&gt;
&lt;p&gt;老刀低头看看，名片上写着一个银行的名字。&lt;/p&gt;
&lt;p&gt;“十二点。到地下超市等我。”她又说。&lt;/p&gt;
&lt;p&gt;老刀看得出她过分的不安，于是点头收起名片，回到隐身的灌木丛后，远远地观望着。很快，又有一个男人从房子里出来，到她身边。男人看上去和老刀年龄相仿，或者年轻两岁，穿着一套很合身的深灰色西装，身材高而宽阔，虽没有突出的肚子，但是觉得整个身体很厚。男人的脸无甚特色，戴眼镜，圆脸，头发向一侧梳得整齐。&lt;/p&gt;
&lt;p&gt;男人搂住依言的腰，吻了她嘴唇一下。依言想躲，但没躲开，颤抖了一下，手挡在身前显得非常勉强。&lt;/p&gt;
&lt;p&gt;老刀开始明白了。&lt;/p&gt;
&lt;p&gt;一辆小车开到房子门前。单人双轮小车，黑色，敞篷，就像电视里看到的古代的马车或黄包车，只是没有马拉，也没有车夫。小车停下，歪向前，依言踏上去，坐下，拢住裙子，让裙摆均匀覆盖膝盖，散到地上。小车缓缓开动了，就像有一匹看不见的马拉着一样。依言坐在车里，小车缓慢而波澜不惊。等依言离开，一辆无人驾驶的汽车开过来，男人上了车。&lt;/p&gt;
&lt;p&gt;老刀在原地来回踱着步子。他觉得有些东西非常憋闷，但又说不出来。他站在阳光里，闭上眼睛，清晨蓝天下清凛干净的空气沁入他的肺。空气给他一种冷静的安慰。&lt;/p&gt;
&lt;p&gt;片刻之后，他才上路。依言给的地址在她家东面，3公里多一点。街上人很少。8车道的宽阔道路上行驶着零星车辆，快速经过，让人看不清车的细节。偶尔有华服的女人乘坐着双轮小车缓缓飘过他身旁，沿步行街，像一场时装秀，端坐着姿态优美。没有人注意到老刀。绿树摇曳，树叶下的林荫路留下长裙的气味。&lt;/p&gt;
&lt;p&gt;依言的办公地在西单某处。这里完全没有高楼，只是围绕着一座花园有零星分布的小楼，楼与楼之间的联系气若游丝，几乎看不出它们是一体。走到地下，才看到相连的通道。&lt;/p&gt;
&lt;p&gt;老刀找到超市。时间还早。一进入超市，就有一辆小车跟上他，每次他停留在货架旁，小车上的屏幕上就显示出这件货物的介绍、评分和同类货物质量比。超市里的东西都写着他看不懂的文字。食物包装精致，小块糕点和水果用诱人的方式摆在盘里，等人自取。他没有触碰任何东西。不过整个超市似乎并没有警卫或店员。&lt;/p&gt;
&lt;p&gt;还不到十二点，顾客就多了起来。有穿西装的男人走进超市，取三明治，在门口刷一下就匆匆离开。还是没有人特别注意老刀。他在门口不起眼的位置等着。&lt;/p&gt;
&lt;p&gt;依言出现了。老刀迎上前去，依言看了看左右，没说话，带他去了隔壁的一家小餐厅。两个穿格子裙子的小机器人迎上来，接过依言手里的小包，又带他们到位子上，递上菜单。依言在菜单上按了几下，小机器人转身，轮子平稳地滑回了后厨。&lt;/p&gt;
&lt;p&gt;两个人面对面坐了片刻，老刀又掏出信封。&lt;/p&gt;
&lt;p&gt;依言却没有接：“……你能听我解释一下吗？” &lt;/p&gt;
&lt;p&gt;老刀把信封推到她面前：“你先收下这个。”&lt;/p&gt;
&lt;p&gt;依言推回给他。&lt;/p&gt;
&lt;p&gt;“你先听我解释一下行吗？”依言又说。&lt;/p&gt;
&lt;p&gt;“你没必要跟我解释，”老刀说，“信不是我写的。我只是送信而已。”&lt;/p&gt;
&lt;p&gt;“可是你回去要告诉说的。”依言低了低头。小机器人送上了两个小盘子，一人一份，是某种红色的生鱼片，薄薄两片，摆成花瓣的形状。依言没有动筷子，老刀也没有。信封被小盘子隔在中央，两个人谁也没再推。“我不是背叛他。去年他来的时候我就已经订婚了。我也不是故意瞒他或欺骗他，或者说……是的，我骗了他，但那是他自己猜的。他见到吴闻来接我，就问是不是我爸爸。我……我没法回答他。你知道，那太尴尬了。我……”&lt;/p&gt;
&lt;p&gt;依言说不下去了。&lt;/p&gt;
&lt;p&gt;老刀等了一会儿说：“我不想追问你们之前的事。你收下信就行了。”&lt;/p&gt;
&lt;p&gt;依言低头好一会儿又抬起来：“你回去以后，能不能替我瞒着他？”&lt;/p&gt;
&lt;p&gt;“为什么？”&lt;/p&gt;
&lt;p&gt;“我不想让他以为我是坏女人耍他。其实我心里是喜欢他的。我也很矛盾。”&lt;/p&gt;
&lt;p&gt;“这些和我没关系。”&lt;/p&gt;
&lt;p&gt;“求你了……我是真的喜欢他。”&lt;/p&gt;
&lt;p&gt;老刀沉默了一会儿，他需要做一个决定。&lt;/p&gt;
&lt;p&gt;“可是你还是结婚了？”他问她。&lt;/p&gt;
&lt;p&gt;“吴闻对我很好。好几年了。”依言说，“他认识我爸妈。我们订婚也很久了。况且……我比秦天大三岁，我怕他不能接受。秦天以为我是实习生。这点也是我不好，我没说实话。最开始只是随口说的，到后来就没法改口了。我真的没想到他是认真的。”&lt;/p&gt;
&lt;p&gt;依言慢慢透露了她的信息。她是这个银行的总裁助理，已经工作两年多了，只是被派往联合国参加培训，赶上那次会议，就帮忙参与了组织。她不需要上班，老公挣的钱足够多，可她不希望总是一个人呆在家里，才出来上班，每天只工作半天，拿半薪。其余的时间自己安排，可以学一些东西。她喜欢学新东西，喜欢认识新人，也喜欢联合国培训的那几个月。她说像她这样的太太很多，半职工作也很多。中午她下了班，下午会有另一个太太去做助理。她说虽然对秦天没有说实话，可是她的心是真诚的。&lt;/p&gt;
&lt;p&gt;“所以，”她给老刀夹了新上来的热菜，“你能不能暂时不告诉他？等我……有机会亲自向他解释可以吗？”&lt;/p&gt;
&lt;p&gt;老刀没有动筷子。他很饿，可是他觉得这时不能吃。&lt;/p&gt;
&lt;p&gt;“可是这等于说我也得撒谎。”老刀说。&lt;/p&gt;
&lt;p&gt;依言回身将小包打开，将钱包取出来，掏出五张一万块的纸币推给老刀。“一点心意，你收下。”&lt;/p&gt;
&lt;p&gt;老刀愣住了。他从来没见过一万块钱的纸钞。他生活里从来不需要花这么大的面额。他不自觉地站起身，感到恼怒。依言推出钱的样子就像是早预料到他会讹诈，这让他受不了。他觉得自己如果拿了，就是接受贿赂，将秦天出卖。虽然他和秦天并没有任何结盟关系，但他觉得自己在背叛他。老刀很希望自己这个时候能将钱扔在地上，转身离去，可是他做不到这一步。他又看了几眼那几张钱，五张薄薄的纸散开摊在桌子上，像一把破扇子。他能感觉它们在他体内产生的力量。它们是淡蓝色，和一千块的褐色与一百块的红色都不一样，显得更加幽深遥远，像是一种挑逗。他几次想再看一眼就离开，可是一直没做到。&lt;/p&gt;
&lt;p&gt;她仍然匆匆翻动小包，前前后后都翻了，最后从一个内袋里又拿出五万块，和刚才的钱摆在一起。“我只带了这么多，你都收下吧。”她说，“你帮帮我。其实我之所以不想告诉他，也是不确定以后会怎么样。也许我有一天真的会有勇气和他在一起呢。”&lt;/p&gt;
&lt;p&gt;老刀看看那十张纸币，又看看她。他觉得她并不相信自己的话，她的声音充满迟疑，出卖了她的心。她只是将一切都推到将来，以消解此时此刻的难堪。她很可能不会和秦天私奔，可是也不想让他讨厌她，于是留着可能性，让自己好过一点。老刀能看出她骗她自己，可是他也想骗自己。他对自己说，他对秦天没有任何义务，秦天只是委托他送信，他把信送到了，现在这笔钱是另一项委托，保守秘密的委托。他又对自己说，也许她和秦天将来真的能在一起也说不定，那样就是成人之美。他还说，想想糖糖，为什么去管别人的事而不管糖糖呢。他似乎安定了一些，手指不知不觉触到了钱的边缘。&lt;/p&gt;
&lt;p&gt;“这钱……太多了。”他给自己一个台阶下，“我不能拿这么多。”&lt;/p&gt;
&lt;p&gt;“拿着吧，没事。”她把钱塞到他手里，“我一个礼拜就挣出来了。没事的。”&lt;/p&gt;
&lt;p&gt;“……那我怎么跟他说？”&lt;/p&gt;
&lt;p&gt;“你就说我现在不能和他在一起，但是我真的喜欢他。我给你写个字条，你帮我带给他。”依言从包里找出一个画着孔雀绣着金边的小本子，轻盈地撕下一张纸，低头写字。她的字看上去像倾斜的芦苇。&lt;/p&gt;
&lt;p&gt;最后，老刀离开餐厅的时候，又回头看了一眼。依言的眼睛注视着墙上的一幅画。她的姿态静默优雅，看上去就像永远都不会离开这里似的。&lt;/p&gt;
&lt;p&gt;他用手捏了捏裤子口袋里的纸币。他讨厌自己，可是他想把纸币抓牢。&lt;/p&gt;
&lt;h2&gt;第四幕&lt;/h2&gt;
&lt;p&gt;老刀从西单出来，依原路返回。重新走早上的路，他觉得倦意丛生，一步也跑不动了。宽阔的步行街两侧是一排垂柳和一排梧桐，正是晚春，都是鲜亮的绿色。他让暖意丛生的午后阳光照亮僵硬的面孔，也照亮空乏的心底。&lt;/p&gt;
&lt;p&gt;他回到早上离开的园子，赫然发现园子里来往的人很多。园子外面两排银杏树庄严茂盛。园门口有黑色小汽车驶入。园里的人多半穿着材质顺滑、剪裁合体的西装，也有穿黑色中式正装的，看上去都有一番眼高于顶的气质。也有外国人。他们有的正在和身边人讨论什么，有的远远地相互打招呼，笑着携手向前走。&lt;/p&gt;
&lt;p&gt;老刀犹豫了一下要到哪里去，街上人很少，他一个人站着极为显眼，去公共场所又容易被注意，他很想回到园子里，早一点找到转换地，到一个没人的角落睡上一觉。他太困了，又不敢在街上睡。他见出入园子的车辆并无停滞，就也尝试着向里走。直到走到园门边上，他才发现有两个小机器人左右逡巡。其他人和车走过都毫无问题，到了老刀这里，小机器人忽然发出嘀嘀的叫声，转着轮子向他驶来。声音在宁静的午后显得刺耳。园里人的目光汇集到他身上。他慌了，不知道是不是自己的衬衫太寒酸。他尝试着低声对小机器人说话，说他的西装落在里面了，可是小机器人只是嘀嘀嗒嗒地叫着，头顶红灯闪烁，什么都不听。园里的人们停下脚步看着他，像是看到小偷或奇怪的人。很快，从最近的建筑中走出三个男人，步履匆匆地向他们跑过来。老刀紧张极了，他想退出去，已经太晚了。&lt;/p&gt;
&lt;p&gt;“出什么事了？”领头的人高声询问着。&lt;/p&gt;
&lt;p&gt;老刀想不出解释的话，手下意识地搓着裤子。&lt;/p&gt;
&lt;p&gt;一个三十几岁的男人走在最前面，一到跟前就用一个纽扣一样的小银盘上上下下地晃，手的轨迹围绕着老刀。他用怀疑的眼神打量他，像用罐头刀试图撬开他的外壳。&lt;/p&gt;
&lt;p&gt;“没记录。”男人将手中的小银盘向身后更年长的男人示意，“带回去吧？”&lt;/p&gt;
&lt;p&gt;老刀突然向后跑，向园外跑。&lt;/p&gt;
&lt;p&gt;可没等他跑出去，两个小机器人悄无声息挡在他面前，扣住他的小腿。它们的手臂是箍，轻轻一扣就合上。他一下子踉跄了，差点摔倒又摔不倒，手臂在空中无力的乱划。&lt;/p&gt;
&lt;p&gt;“跑什么？”年轻男人更严厉地走到他面前，瞪着他的眼睛。&lt;/p&gt;
&lt;p&gt;“我……”老刀头脑嗡嗡响。&lt;/p&gt;
&lt;p&gt;两个小机器人将他的两条小腿扣紧，抬起，放在它们轮子边上的平台上，然后异常同步地向最近的房子驶去，平稳迅速，保持并肩，从远处看上去，或许会以为老刀脚踩风火轮。老刀毫无办法，除了心里暗喊一声糟糕，简直没有别的话说。他懊恼自己如此大意，人这么多的地方，怎么可能没有安全保障。他责怪自己是困倦得昏了头，竟然在这样大的安全关节上犯如此低级的错误。这下一切完蛋了，他想，钱都没了，还要坐牢。&lt;/p&gt;
&lt;p&gt;小机器人从小路绕向建筑后门，在后门的门廊里停下来。三个男人跟了上来。年轻男人和年长男人似乎就老刀的处理问题起了争执，但他们的声音很低，老刀听不见。片刻之后，年长男人走到他身边，将小机器人解锁，然后拉着他的大臂走上二楼。&lt;/p&gt;
&lt;p&gt;老刀叹了一口气，横下一条心，觉得事到如今，只好认命。&lt;/p&gt;
&lt;p&gt;年长者带他进入一个房间。他发现这是一个旅馆房间，非常大，比秦天的公寓客厅还大，似乎有自己租的房子两倍大。房间的色调是暗沉的金褐色，一张极宽大的双人床摆在中央。床头背后的墙面上是颜色过渡的抽象图案，落地窗，白色半透明纱帘，窗前是一个小圆桌和两张沙发。他心里惴惴。不知道年长者的身份和态度。&lt;/p&gt;
&lt;p&gt;“坐吧，坐吧。”年长者拍拍他肩膀，笑笑，“没事了。”&lt;/p&gt;
&lt;p&gt;老刀狐疑地看着他。&lt;/p&gt;
&lt;p&gt;“你是第三空间来的吧？”年长者把他拉到沙发边上，伸手示意。&lt;/p&gt;
&lt;p&gt;“您怎么知道？”老刀无法撒谎。&lt;/p&gt;
&lt;p&gt;“从你裤子上。”年长者用手指指他的裤腰，“你那商标还没剪呢。这牌子只有第三空间有卖的。我小时候我妈就喜欢给我爸买这牌子。”&lt;/p&gt;
&lt;p&gt;“您是……”&lt;/p&gt;
&lt;p&gt;“别您您的，叫你吧。我估摸着我也比你大不了几岁。你今年多大？我五十二。……你看看，就比你大四岁。”他顿了一下，又说，“我叫葛大平，你叫我老葛吧。”&lt;/p&gt;
&lt;p&gt;老刀放松了些。老葛把西装脱了，活动了一下膀子，从墙壁里接了一杯热水，递给老刀。他长长的脸，眼角眉梢和两颊都有些下坠，戴一副眼镜，也向下耷拉着，头发有点自来卷，蓬松地堆在头顶，说起话来眉毛一跳一跳，很有喜剧效果。他自己泡了点茶，问老刀要不要，老刀摇摇头。&lt;/p&gt;
&lt;p&gt;“我原来也是第三空间的。咱也算半个老乡吧。”老葛说，“所以不用太拘束。我还是能管点事儿，不会把你送出去的。”&lt;/p&gt;
&lt;p&gt;老刀长长地出了口气，心里感叹万幸。他于是把自己到第二、第一空间的始末讲了一遍，略去依言感情的细节，只说送到了信，就等着回去。&lt;/p&gt;
&lt;p&gt;老葛于是也不见外，把他自己的情况讲了。他从小也在第三空间长大，父母都给人送货。十五岁的时候考上了军校，后来一直当兵，文化兵，研究雷达，能吃苦，技术又做得不错，赶上机遇又好，居然升到了雷达部门主管，大校军衔。家里没背景不可能再升，就申请转业，到了第一空间一个支持性部门，专给政府企业做后勤保障，组织会议出行，安排各种场面。虽然是蓝领的活儿，但因为涉及的都是政要，又要协调管理，就一直住在第一空间。这种人也不少，厨师、大夫、秘书、管家，都算是高级蓝领了。他们这个机构安排过很多重大场合，老葛现在是主任。老刀知道，老葛说的谦虚，说是蓝领，其实能在第一空间做事的都是牛人，即使厨师也不简单，更何况他从第三空间上来，能管雷达。&lt;/p&gt;
&lt;p&gt;“你在这儿睡一会儿。待会儿晚上我带你吃饭去。”老葛说。&lt;/p&gt;
&lt;p&gt;老刀受宠若惊，不大相信自己的好运。他心里还有担心，但是白色的床单和错落堆积的枕头显出召唤气息，他的腿立刻发软了，倒头昏昏沉沉睡了几个小时。&lt;/p&gt;
&lt;p&gt;醒来的时候天色暗了，老葛正对着镜子捋头发。他向老刀指了指沙发上的一套西装制服，让他换上，又给他胸口别上一个微微闪着红光的小徽章，身份认证。&lt;/p&gt;
&lt;p&gt;下楼来，老刀发现原来这里有这么多人。似乎刚刚散会，在大厅里聚集三三两两说话。大厅一侧是会场，门还开着，门看上去很厚，包着红褐色皮子；另一侧是一个一个铺着白色桌布的高脚桌，桌布在桌面下用金色缎带打了蝴蝶结，桌中央的小花瓶插着一只百合，花瓶旁边摆着饼干和干果，一旁的长桌上则有红酒和咖啡供应。聊天的人们在高脚桌之间穿梭，小机器人头顶托盘，收拾喝光的酒杯。&lt;/p&gt;
&lt;p&gt;老刀尽量镇定地跟着老葛。走到会场内，他忽然看到一面巨大的展示牌，上面写着：&lt;/p&gt;
&lt;p&gt;折叠城市五十年。&lt;/p&gt;
&lt;p&gt;“这是……什么？”他问老葛。&lt;/p&gt;
&lt;p&gt;“哦，庆典啊。”老葛正在监督场内布置，“小赵，你来一下，你去把桌签再核对一遍。机器人有时候还是不如人靠谱，它们认死理儿。”&lt;/p&gt;
&lt;p&gt;老刀看到，会场里现在是晚宴的布置，每张大圆桌上都摆着鲜艳的花朵。&lt;/p&gt;
&lt;p&gt;他有一种恍惚的感觉，站在角落里，看着会场中央巨大的吊灯，像是被某种光芒四射的现实笼罩，却只存在在它的边缘。舞台中央是演讲的高台，背后的布景流动播映着北京城的画面。大概是航拍，拍到了全城的风景，清晨和日暮的光影，紫红色暗蓝色天空，云层快速流转，月亮从角落上升起，太阳在屋檐上沉落。大气中正的布局，沿中轴线对称的城市设计，延伸到六环的青砖院落和大面积绿地花园。中式风格的剧院，日本式美术馆，极简主义风格的音乐厅建筑群。然后是城市的全景，真正意义上的全景，包含转换的整个城市双面镜头：大地翻转，另一面城市，边角锐利的写字楼，朝气蓬勃的上班族；夜晚的霓虹，白昼一样的天空，高耸入云的公租房，影院和舞厅的娱乐。&lt;/p&gt;
&lt;p&gt;只是没有老刀上班的地方。&lt;/p&gt;
&lt;p&gt;他仔细地盯着屏幕，不知道其中会不会展示建城时的历史。他希望能看见父亲的时代。小时候父亲总是用手指着窗外的楼，说“当时我们”。狭小的房间正中央挂着陈旧的照片，照片里的父亲重复着垒砖的动作，一遍一遍无穷无尽。他那时每天都要看见那照片很多遍，几乎已经腻烦了，可是这时他希望影像中出现哪怕一小段垒砖的镜头。&lt;/p&gt;
&lt;p&gt;他沉浸在自己的恍惚中。这也是他第一次看到转换的全景。他几乎没注意到自己是怎么坐下的，也没注意到周围人的落座，台上人讲话的前几分钟，他并没有注意听。&lt;/p&gt;
&lt;p&gt;“……有利于服务业的发展，服务业依赖于人口规模和密度。我们现在的城市服务业已经占到GDP85%以上，符合世界第一流都市的普遍特征。另外最重要的就是绿色经济和循环经济。”这句话抓住了老刀的注意力，循环经济和绿色经济是他们工作站的口号，写得比人还大贴在墙上。他望向台上的演讲人，是个白发老人，但是精神显得异常饱满，“……通过垃圾的完全分类处理，我们提前实现了本世纪节能减排的目标，减少污染，也发展出成体系成规模的循环经济，每年废旧电子产品中回收的贵金属已经完全投入再生产，塑料的回收率也已达到80%以上。回收直接与再加工工厂相连……”&lt;/p&gt;
&lt;p&gt;老刀有远亲在再加工工厂工作，在科技园区，远离城市，只有工厂和工厂和工厂。据说那边的工厂都差不多，机器自动作业，工人很少，少量工人晚上聚集着，就像荒野部落。&lt;/p&gt;
&lt;p&gt;他仍然恍惚着。演讲结束之后，热烈的掌声响起，才将他从自己的纷乱念头中拉出来，他也跟着鼓了掌，虽然不知道为什么。他看到演讲人从舞台上走下来，回到主桌上正中间的座位。所有人的目光都跟着他。&lt;/p&gt;
&lt;p&gt;忽然老刀看到了吴闻。&lt;/p&gt;
&lt;p&gt;吴闻坐在主桌旁边一桌，见演讲人回来就起身去敬酒，然后似乎有什么话要问演讲人。演讲人又站起身，跟吴闻一起到大厅里。老刀不自觉地站起来，心里充满好奇，也跟着他们。老葛不知道到哪里去了，周围开始上菜。&lt;/p&gt;
&lt;p&gt;老刀到了大厅，远远地观望，对话只能听见片段。&lt;/p&gt;
&lt;p&gt;“……批这个有很多好处。”吴闻说，“是，我看过他们的设备了……自动化处理垃圾，用溶液消解，大规模提取材质……清洁，成本也低……您能不能考虑一下？”&lt;/p&gt;
&lt;p&gt;吴闻的声音不高，但老刀清楚地听见“处理垃圾”的字眼，不由自主凑上前去。&lt;/p&gt;
&lt;p&gt;白发老人的表情相当复杂，他等吴闻说完，过了一会儿才问：“你确定溶液无污染？”&lt;/p&gt;
&lt;p&gt;吴闻有点犹豫：“现在还是有一点……不过很快就能减低到最低。”&lt;/p&gt;
&lt;p&gt;老刀离得很近了。&lt;/p&gt;
&lt;p&gt;白发老人摇了摇头，眼睛盯着吴闻：“事情哪是那么简单的，你这个项目要是上马了，大规模一改造，又不需要工人，现在那些劳动力怎么办，上千万垃圾工失业怎么办？”&lt;/p&gt;
&lt;p&gt;白发老人说完转过身，又返回会场。吴闻呆愣愣地站在原地。一个从始至终跟着老人的秘书模样的人走到吴闻身旁，同情地说：“您回去好好吃饭吧。别想了。其实您应该明白这道理，就业的事是顶天的事。您以为这种技术以前就没人做吗？”&lt;/p&gt;
&lt;p&gt;老刀能听出这是与他有关的事，但他摸不准怎样是好的。吴闻的脸显出一种迷惑、懊恼而又顺从的神情，老刀忽然觉得，他也有软弱的地方。&lt;/p&gt;
&lt;p&gt;这时，白发老人的秘书忽然注意到老刀。&lt;/p&gt;
&lt;p&gt;“你是新来的？”他突然问。&lt;/p&gt;
&lt;p&gt;“啊……嗯。”老刀吓了一跳。&lt;/p&gt;
&lt;p&gt;“叫什么名字？我怎么不知道最近进人了。”&lt;/p&gt;
&lt;p&gt;老刀有些慌，心砰砰跳，他不知道该说些什么。他指了指胸口上别着的工作人员徽章，仿佛期望那上面有个名字浮现出来。但徽章上什么都没有。他的手心涌出汗。秘书看着他，眼中的怀疑更甚了。他随手拉着一个会务人员，那人说不认识老刀。&lt;/p&gt;
&lt;p&gt;秘书的脸铁青着，一只手抓住老刀的手臂，另一只手拨了通讯器。&lt;/p&gt;
&lt;p&gt;老刀的心提到嗓子眼，就在那一刹那，他看到了老葛的身影。&lt;/p&gt;
&lt;p&gt;老葛一边匆匆跑过来，一边按下通讯器，笑着和秘书打招呼，点头弯腰，向秘书解释说这是临时从其他单位借调过来的同事，开会人手不够，临时帮忙的。秘书见老葛知情，也就不再追究，返回会场。老葛将老刀又带回自己的房间，免得再被人撞见查检。深究起来没有身份认证，老葛也做不得主。&lt;/p&gt;
&lt;p&gt;“没有吃席的命啊。”老葛笑道，“你等着吧，待会儿我给你弄点吃的回来。”&lt;/p&gt;
&lt;p&gt;老刀躺在床上，又迷迷糊糊睡了。他反复想着吴闻和白发老人说的话，自动垃圾处理，这是什么样的呢，如果真的这样，是好还是不好呢。&lt;/p&gt;
&lt;p&gt;再次醒来时，老刀闻到一碟子香味，老葛已经在小圆桌上摆了几碟子菜，还正在从墙上的烤箱中把剩下一个菜端出来。老葛又拿来半瓶白酒和两个玻璃杯，倒上。&lt;/p&gt;
&lt;p&gt;“有一桌就坐了俩人，我把没怎么动过的菜弄了点回来，你凑合吃，别嫌弃就行。他们吃了一会儿就走了。”老葛说。&lt;/p&gt;
&lt;p&gt;“哪儿能嫌弃呢。”老刀说，“有口吃的就感激不尽了。这么好的菜。这些菜很贵吧？”&lt;/p&gt;
&lt;p&gt;“这儿的菜不对外，所以都不标价。我也不知道多少钱。”老葛已经开动了筷子，“也就一般吧。估计一两万之间，个别贵一点可能三四万。就那么回事。”&lt;/p&gt;
&lt;p&gt;老刀吃了两口就真的觉得饿了。他有抗饥饿的办法，忍上一天不吃东西也可以，身体会有些颤抖发飘，但精神不受影响。直到这时，他才发觉自己的饥饿。他只想快点咀嚼，牙齿的速度赶不上胃口空虚的速度。吃得急了，就喝一口。这白酒很香，不辣。老葛慢悠悠的，微笑着看着他。&lt;/p&gt;
&lt;p&gt;“对了，”老刀吃得半饱时，想起刚才的事，“今天那个演讲人是谁？我看着很面熟。”&lt;/p&gt;
&lt;p&gt;“也总上电视嘛。”老葛说，“我们的顶头上司。很厉害的老头儿。他可是管实事儿的，城市运作的事儿都归他管。”&lt;/p&gt;
&lt;p&gt;“他们今天说起垃圾自动处理的事儿。你说以后会改造吗？”&lt;/p&gt;
&lt;p&gt;“这事儿啊，不好说，”老葛砸了口酒，打了个嗝，“我看够呛。关键是，你得知道当初为啥弄人工处理。其实当初的情况就跟欧洲二十世纪末差不多，经济发展，但失业率上升，印钱也不管用，菲利普斯曲线不符合。”&lt;/p&gt;
&lt;p&gt;他看老刀一脸茫然，呵呵笑了起来：“算了，这些东西你也不懂。”&lt;/p&gt;
&lt;p&gt;他跟老刀碰了碰杯子，两人一齐喝了又斟上。&lt;/p&gt;
&lt;p&gt;“反正就说失业吧，这你肯定懂。”老葛接着说，“人工成本往上涨，机器成本往下降，到一定时候就是机器便宜，生产力一改造，升级了，GDP上去了，失业也上去了。怎么办？政策保护？福利？越保护工厂越不雇人。你现在上城外看看，那几公里的厂区就没几个人。农场不也是吗。大农场一搞几千亩地，全设备耕种，根本要不了几个人。咱们当时怎么搞过欧美的，不就是这么规模化搞的吗。但问题是，地都腾出来了，人都省出来了，这些人干嘛去呢。欧洲那边是强行减少每人工作时间，增加就业机会，可是这样没活力你明白吗。最好的办法是彻底减少一些人的生活时间，再给他们找到活儿干。你明白了吧？就是塞到夜里。这样还有一个好处，就是每次通货膨胀几乎传不到底层去，印钞票、花钞票都是能贷款的人消化了，GDP涨了，底下的物价却不涨。人们根本不知道。”&lt;/p&gt;
&lt;p&gt;老刀听得似懂非懂，但是老葛的话里有一股凉意，他还是能听出来的。老葛还是嬉笑的腔调，但与其说是嬉笑，倒不如说是不愿意让自己的语气太直白而故意如此。&lt;/p&gt;
&lt;p&gt;“这话说着有点冷。”老葛自己也承认，“可就是这么回事。我也不是住在这儿了就说话向着这儿。只是这么多年过来，人就木了，好多事儿没法改变，也只当那么回事了。”&lt;/p&gt;
&lt;p&gt;老刀有点明白老葛的意思了，可他不知道该说什么好。&lt;/p&gt;
&lt;p&gt;两人都有点醉。他们趁着醉意，聊了不少以前的事，聊小时候吃的东西，学校的打架。老葛最喜欢吃酸辣粉和臭豆腐，在第一空间这么久都吃不到，心里想得痒痒。老葛说起自己的父母，他们还在第三空间，他也不能总回去，每次回去都要打报告申请，实在不太方便。他说第三空间和第一空间之间有官方通道，有不少特殊的人也总是在其中往来。他希望老刀帮他带点东西回去，弥补一下他自己亏欠的心。老刀讲了他孤独的少年时光。&lt;/p&gt;
&lt;p&gt;昏黄的灯光中，老刀想起过去。一个人游荡在垃圾场边缘的所有时光。&lt;/p&gt;
&lt;p&gt;不知不觉已经是深夜。老葛还要去看一下夜里会场的安置，就又带老刀下楼。楼下还有未结束的舞会末尾，三三两两男女正从舞厅中走出。老葛说企业家大半精力旺盛，经常跳舞到凌晨。散场的舞厅器物凌乱，像女人卸了妆。老葛看着小机器人在狼藉中一一收拾，笑称这是第一空间唯一真实的片刻。&lt;/p&gt;
&lt;p&gt;老刀看了看时间，还有三个小时转换。他收拾了一下心情，该走了。&lt;/p&gt;
&lt;h2&gt;第五幕&lt;/h2&gt;
&lt;p&gt;白发演讲人在晚宴之后回到自己的办公室，处理了一些文件，又和欧洲进行了视频通话。十二点感觉疲劳，摘下眼镜揉了揉鼻梁两侧，准备回家。他经常工作到午夜。&lt;/p&gt;
&lt;p&gt;电话突然响了，他按下耳机。是秘书。&lt;/p&gt;
&lt;p&gt;大会研究组出了状况。之前印好的大会宣言中有一个数据之前计算结果有误，白天突然有人发现。宣言在会议第二天要向世界宣读，因而会议组请示要不要把宣言重新印刷。白发老人当即批准。这是大事，不能有误。他问是谁负责此事，秘书说，是吴闻主任。&lt;/p&gt;
&lt;p&gt;他靠在沙发上小睡。清晨四点，电话又响了。印刷有点慢，预计还要一个小时。&lt;/p&gt;
&lt;p&gt;他起身望向窗外。夜深人静，漆黑的夜空能看到静谧的猎户座亮星。&lt;/p&gt;
&lt;p&gt;猎户座亮星映在镜面般的湖水中。老刀坐在湖水边上，等待转换来临。&lt;/p&gt;
&lt;p&gt;他看着夜色中的园林，猜想这可能是自己最后一次看这片风景。他并不忧伤留恋，这里虽然静美，可是和他没关系，他并不钦羡嫉妒。他只是很想记住这段经历。夜里灯光很少，比第三空间遍布的霓虹灯少很多，建筑散发着沉睡的呼吸，幽静安宁。&lt;/p&gt;
&lt;p&gt;清晨五点，秘书打电话说，材料印好了，还没出车间，问是否人为推迟转换的时间。&lt;/p&gt;
&lt;p&gt;白发老人斩钉截铁地说，废话，当然推迟。&lt;/p&gt;
&lt;p&gt;清晨五点四十分，印刷品抵达会场，但还需要分装在三千个会议夹子中。&lt;/p&gt;
&lt;p&gt;老刀看到了依稀的晨光，这个季节六点还没有天亮，但已经能看到蒙蒙曙光。&lt;/p&gt;
&lt;p&gt;他做好了一切准备，反复看手机上的时间。有一点奇怪，已经只有一两分钟到六点了，还是没有任何动静。他猜想也许第一空间的转换更平稳顺滑。&lt;/p&gt;
&lt;p&gt;清晨六点十分，分装结束。&lt;/p&gt;
&lt;p&gt;白发老人松了一口气，下令转换开始。&lt;/p&gt;
&lt;p&gt;老刀发现地面终于动了，他站起身，活动了一下有点麻木的手脚，小心翼翼来到边缘。土地的缝隙开始拉大，缝隙两边同时向上掀起。他沿着其中一边往截面上移动，背身挪移，先用脚试探着，手扶住地面退行。大地开始翻转。&lt;/p&gt;
&lt;p&gt;六点二十分，秘书打来紧急电话，说吴闻主任不小心将存着重要文件的数据key遗忘在会场，担心会被机器人清理，需要立即取回。&lt;/p&gt;
&lt;p&gt;白发老人有点恼怒，但也只好令转换停止，恢复原状。&lt;/p&gt;
&lt;p&gt;老刀在截面上正慢慢挪移，忽然感觉土地的移动停止了，接着开始调转方向，已错开的土地开始合拢。他吓了一跳，连忙向回攀爬。他害怕滚落，手脚并用，异常小心。&lt;/p&gt;
&lt;p&gt;土地回归的速度比他想象的快，就在他爬到地表的时候，土地合拢了，他的一条小腿被两块土地夹在中间，尽管是泥土，不足以切筋断骨，但力量十足，他试了几次也无法脱出。他心里大叫糟糕，头顶因为焦急和疼痛渗出汗水。他不知道是否被人发现了。&lt;/p&gt;
&lt;p&gt;老刀趴在地上，静听着周围的声音。他似乎听到匆匆接近的脚步声。他想象着很快就有警察过来，将他抓起来，夹住的小腿会被砍断，带着疮口扔到监牢里。他不知道自己是什么时候暴露了身份。他伏在青草覆盖的泥土上，感觉到晨露的冰凉。湿气从领口和袖口透入他的身体，让他觉得清醒，却又忍不住战栗。他默数着时间，期盼这只是技术故障。他设想着自己如果被抓住了该说些什么。也许他该交待自己二十八年工作的勤恳诚实，赚一点同情分。他不知道自己会不会被审判。命运在前方逼人不已。&lt;/p&gt;
&lt;p&gt;命运直抵胸膛。回想这四十八小时的全部经历，最让他印象深刻的是最后一晚老葛说过的话。他觉得自己似乎接近了些许真相，因而见到命运的轮廓。可是那轮廓太远，太冷静，太遥不可及。他不知道了解一切有什么意义，如果只是看清楚一些事情，却不能改变，又有什么意义。他连看都还无法看清，命运对他就像偶尔显出形状的云朵，倏忽之间又看不到了。他知道自己仍然是数字。在5128万这个数字中，他只是最普通的一个。如果偏生是那128万中的一个，还会被四舍五入，就像从来没存在过，连尘土都不算。他抓住地上的草。&lt;/p&gt;
&lt;p&gt;六点三十分，吴闻取回数据key。六点四十分，吴闻回到房间。&lt;/p&gt;
&lt;p&gt;六点四十五分，白发老人终于疲倦地倒在办公室的小床上。指令已经按下，世界的齿轮开始缓缓运转。书桌和茶几表面伸出透明的塑料盖子，将一切物品罩住并固定。小床散发出催眠气体，四周立起围栏，然后从地面脱离，地面翻转，床像一只篮子始终保持水平。&lt;/p&gt;
&lt;p&gt;转换重新启动了。&lt;/p&gt;
&lt;p&gt;老刀在三十分钟的绝望之后突然看到生机。大地又动了起来。他在第一时间拼尽力气将小腿抽离出来，在土地掀起足够高度的时候重新回到截面上。他更小心地撤退。血液复苏的小腿开始刺痒疼痛，如百爪挠心，几次让他摔倒，疼得无法忍受，只好用牙齿咬住拳头。他摔倒爬起，又摔倒又爬起，在角度飞速变化的土地截面上维持艰难地平衡。&lt;/p&gt;
&lt;p&gt;他不记得自己怎么拖着腿上楼，只记得秦天开门时，他昏了过去。&lt;/p&gt;
&lt;p&gt;在第二空间，老刀睡了十个小时。秦天找同学来帮他处理了腿伤。肌肉和软组织大面积受损，很长一段时间会妨碍走路，但所幸骨头没断。他醒来后将依言的信交给秦天，看秦天幸福而又失落的样子，什么话也没有说。他知道，秦天会沉浸距离的期冀中很长时间。&lt;/p&gt;
&lt;p&gt;再回到第三空间，他感觉像是已经走了一个月。城市仍然在缓慢苏醒，城市居民只过了平常的一场睡眠，和前一天连续。不会有人发现老刀的离开。&lt;/p&gt;
&lt;p&gt;他在步行街营业的第一时间坐到塑料桌旁，要了一盘炒面，生平第一次加了一份肉丝。只是一次而已，他想，可以犒劳一下自己。然后他去了老葛家，将老葛给父母的两盒药带给他们。两位老人都已经不大能走动了，一个木讷的小姑娘住在家里看护他们。&lt;/p&gt;
&lt;p&gt;他拖着伤腿缓缓踱回自己租的房子。楼道里喧扰嘈杂，充满刚睡醒时洗漱冲厕所和吵闹的声音，蓬乱的头发和乱敞的睡衣在门里门外穿梭。他等了很久电梯，刚上楼就听见争吵。他仔细一看，是隔壁的女孩阑阑和阿贝在和收租的老太太争吵。整栋楼是公租房，但是社区有统一收租的代理人，每栋楼又有分包，甚至每层有单独的收租人。老太太也是老住户了，儿子不知道跑到哪里去了，她长得瘦又干，单独一个人住着，房门总是关闭，不和人来往。阑阑和阿贝在这一层算是新人，两个卖衣服的女孩子。阿贝的声音很高，阑阑拉着她，阿贝抢白了阑阑几句，阑阑倒哭了。&lt;/p&gt;
&lt;p&gt;“咱们都是按合同来的哦。”老太太用手戳着墙壁上屏幕里滚动的条文，“我这个人从不撒谎唉。你们知不知道什么是合同咧？秋冬加收10%取暖费，合同里写得清清楚楚唉。”&lt;/p&gt;
&lt;p&gt;“凭什么啊？凭什么？”阿贝扬着下巴，一边狠狠地梳着头发，“你以为你那点小猫腻我们不知道？我们上班时你全把空调关了，最后你这按电费交钱，我们这给你白交供暖费。你蒙谁啊你！每天下班回来这屋里冷得跟冰一样。你以为我们新来的好欺负吗？”&lt;/p&gt;
&lt;p&gt;阿贝的声音尖而脆，划得空气道道裂痕。老刀看着阿贝的脸，年轻、饱满而意气的脸，很漂亮。她和阑阑帮他很多，他不在家的时候，她们经常帮他照看糖糖，也会给他熬点粥。他忽然想让阿贝不要吵了，忘了这些细节，只是不要吵了。他想告诉她女孩子应该安安静静坐着，让裙子盖住膝盖，微微一笑露出好看的牙齿，轻声说话，那样才有人爱。可是他知道她们需要的不是这些。&lt;/p&gt;
&lt;p&gt;他从衣服的内衬掏出一张一万块的钞票，虚弱地递给老太太。老太太目瞪口呆，阿贝、阑阑看得傻了。他不想解释，摆摆手回到自己的房间。&lt;/p&gt;
&lt;p&gt;摇篮里，糖糖刚刚睡醒，正迷糊着揉眼睛。他看着糖糖的脸，疲倦了一天的心软下来。他想起最初在垃圾站门口抱起糖糖时，她那张脏兮兮的哭累了的小脸。他从没后悔将她抱来。她笑了，吧唧了一下小嘴。他觉得自己还是幸运的。尽管伤了腿，但毕竟没被抓住，还带了钱回来。他不知道糖糖什么时候才能学会唱歌跳舞，成为一个淑女。&lt;/p&gt;
&lt;p&gt;他看看时间，该去上班了。&lt;/p&gt;
&lt;p&gt;（全文完）&lt;/p&gt;</summary><category term="杂文"></category></entry><entry><title>Docker基础技术：Linux Namespace（下）</title><link href="http://king32783784.github.io/2016/08/12/Docker/" rel="alternate"></link><published>2016-08-12T00:00:00+08:00</published><updated>2016-08-12T00:00:00+08:00</updated><author><name>others</name></author><id>tag:king32783784.github.io,2016-08-12:2016/08/12/Docker/</id><summary type="html">&lt;p&gt;在 &lt;a href="https://king32783784.github.io/lipeng/2016/08/11/Docker/"&gt;Docker基础技术：Linux Namespace（上篇)&lt;/a&gt;中我们了解了，UTD、IPC、PID、Mount 四个namespace，我们模仿Docker做了一个相当相当山寨的镜像。在这一篇中，主要想向大家介绍Linux的User和Network的Namespace。&lt;/p&gt;
&lt;p&gt;好，下面我们就介绍一下还剩下的这两个Namespace。&lt;/p&gt;
&lt;h4&gt;User Namespace&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;User Namespace&lt;/strong&gt; 主要是用了CLONE_NEWUSER的参数。使用了这个参数后，内部看到的UID和GID已经与外部不同了，默认显示为65534。那是因为容器找不到其真正的UID所以，设置上了最大的UID（其设置定义在/proc/sys/kernel/overflowuid）。&lt;/p&gt;
&lt;p&gt;要把容器中的uid和真实系统的uid给映射在一起，需要修改 &lt;strong&gt;/proc/&lt;pid&gt;/uid_map&lt;/strong&gt;  和 &lt;strong&gt;/proc/&lt;pid&gt;/gid_map&lt;/strong&gt; 这两个文件。这两个文件的格式为：&lt;/p&gt;
&lt;p&gt;ID-inside-ns ID-outside-ns length&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个字段ID-inside-ns表示在容器显示的UID或GID，&lt;/li&gt;
&lt;li&gt;第二个字段ID-outside-ns表示容器外映射的真实的UID或GID。&lt;/li&gt;
&lt;li&gt;第三个字段表示映射的范围，一般填1，表示一一对应。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如，把真实的uid=1000映射成容器内的uid=0&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ cat /proc/2465/uid_map
     &lt;span class="m"&gt;0&lt;/span&gt;       &lt;span class="m"&gt;1000&lt;/span&gt;          &lt;span class="m"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;再比如下面的示例：表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ cat /proc/&lt;span class="nv"&gt;$$&lt;/span&gt;/uid_map
     &lt;span class="m"&gt;0&lt;/span&gt;          &lt;span class="m"&gt;0&lt;/span&gt;          &lt;span class="m"&gt;4294967295&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另外，需要注意的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写这两个文件的进程需要这个namespace中的CAP_SETUID (CAP_SETGID)权限（可参看Capabilities）&lt;/li&gt;
&lt;li&gt;写入的进程必须是此user namespace的父或子的user namespace进程。&lt;/li&gt;
&lt;li&gt;另外需要满如下条件之一：1）父进程将effective uid/gid映射到子进程的user namespace中，2）父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid。&lt;/li&gt;
&lt;li&gt;这些规则看着都烦，我们来看程序吧（下面的程序有点长，但是非常简单，如果你读过《Unix网络编程》上卷，你应该可以看懂):&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define _GNU_SOURCE&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/mount.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/capability.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sched.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#define STACK_SIZE (1024 * 1024)&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;container_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;STACK_SIZE&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;container_args&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;/bin/bash&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nb"&gt;NULL&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pipefd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;set_map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;inside_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;outside_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;mapfd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;w&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;mapfd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;open file error&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mapfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;%d %d %d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;inside_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;outside_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;fclose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mapfd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;set_uid_map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;inside_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;outside_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;sprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/proc/%d/uid_map&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;set_map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;inside_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;outside_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;set_gid_map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;inside_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;outside_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;sprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/proc/%d/gid_map&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;set_map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;inside_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;outside_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;container_main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Container [%5d] - inside the container!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;getpid&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Container: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;geteuid&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;getegid&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;getuid&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;getgid&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="cm"&gt;/* 等待父进程通知后再往下执行（进程间的同步） */&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pipefd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pipefd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Container [%5d] - setup hostname!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;getpid&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="c1"&gt;//set hostname&lt;/span&gt;
    &lt;span class="n"&gt;sethostname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;container&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;//remount &amp;quot;/proc&amp;quot; to make sure the &amp;quot;top&amp;quot; and &amp;quot;ps&amp;quot; show container&amp;#39;s information&lt;/span&gt;
    &lt;span class="n"&gt;mount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;proc&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/proc&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;proc&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;execv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;container_args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;container_args&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Something&amp;#39;s wrong!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;gid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;getgid&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;uid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;getuid&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parent: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;geteuid&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;getegid&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;getuid&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;getgid&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="n"&gt;pipe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pipefd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parent [%5d] - start a container!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;getpid&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;container_pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;container_main&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;container_stack&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;STACK_SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;CLONE_NEWUTS&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;CLONE_NEWPID&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;CLONE_NEWNS&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;CLONE_NEWUSER&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;SIGCHLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;


    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parent [%5d] - Container [%5d]!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;getpid&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;container_pid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;//To map the uid/gid,&lt;/span&gt;
   &lt;span class="c1"&gt;//   we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent&lt;/span&gt;
    &lt;span class="c1"&gt;//The file format is&lt;/span&gt;
    &lt;span class="c1"&gt;//   ID-inside-ns   ID-outside-ns   length&lt;/span&gt;
    &lt;span class="c1"&gt;//if no mapping,&lt;/span&gt;
    &lt;span class="c1"&gt;//   the uid will be taken from /proc/sys/kernel/overflowuid&lt;/span&gt;
    &lt;span class="c1"&gt;//   the gid will be taken from /proc/sys/kernel/overflowgid&lt;/span&gt;
    &lt;span class="n"&gt;set_uid_map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;container_pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;uid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;set_gid_map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;container_pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;gid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parent [%5d] - user/group mapping done!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;getpid&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="cm"&gt;/* 通知子进程 */&lt;/span&gt;
    &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pipefd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

    &lt;span class="n"&gt;waitpid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;container_pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parent - container stopped!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的程序，我们用了一个pipe来对父子进程进行同步，为什么要这样做？因为子进程中有一个execv的系统调用，这个系统调用会把当前子进程的进程空间给全部覆盖掉，我们希望在execv之前就做好user namespace的uid/gid的映射，这样，execv运行的/bin/bash就会因为我们设置了uid为0的inside-uid而变成#号的提示符。&lt;/p&gt;
&lt;p&gt;整个程序的运行效果如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;hchen&lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;ubuntu&lt;/span&gt;&lt;span class="o"&gt;:~$&lt;/span&gt; &lt;span class="nt"&gt;id&lt;/span&gt;
&lt;span class="nt"&gt;uid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;1000&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;hchen&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nt"&gt;gid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;1000&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;hchen&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nt"&gt;groups&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;1000&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;hchen&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nt"&gt;hchen&lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;ubuntu&lt;/span&gt;&lt;span class="o"&gt;:~$&lt;/span&gt; &lt;span class="o"&gt;./&lt;/span&gt;&lt;span class="nt"&gt;user&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;--&lt;/span&gt;&lt;span class="err"&gt;以&lt;/span&gt;&lt;span class="nt"&gt;hchen&lt;/span&gt;&lt;span class="err"&gt;用户运行&lt;/span&gt;
&lt;span class="nt"&gt;Parent&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;eUID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="nt"&gt;eGID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;1000&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;UID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;1000&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;GID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;1000&lt;/span&gt;
&lt;span class="nt"&gt;Parent&lt;/span&gt; &lt;span class="cp"&gt;[&lt;/span&gt; &lt;span class="mi"&gt;3262&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;start&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="nt"&gt;container&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;
&lt;span class="nt"&gt;Parent&lt;/span&gt; &lt;span class="cp"&gt;[&lt;/span&gt; &lt;span class="mi"&gt;3262&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;Container&lt;/span&gt; &lt;span class="cp"&gt;[&lt;/span&gt; &lt;span class="mi"&gt;3263&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;
&lt;span class="nt"&gt;Parent&lt;/span&gt; &lt;span class="cp"&gt;[&lt;/span&gt; &lt;span class="mi"&gt;3262&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;user&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;group&lt;/span&gt; &lt;span class="nt"&gt;mapping&lt;/span&gt; &lt;span class="nt"&gt;done&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;
&lt;span class="nt"&gt;Container&lt;/span&gt; &lt;span class="cp"&gt;[&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;inside&lt;/span&gt; &lt;span class="nt"&gt;the&lt;/span&gt; &lt;span class="nt"&gt;container&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;
&lt;span class="nt"&gt;Container&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;eUID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="nt"&gt;eGID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;UID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;GID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;0&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;---Container&lt;/span&gt;&lt;span class="err"&gt;里的&lt;/span&gt;&lt;span class="nt"&gt;UID&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;GID&lt;/span&gt;&lt;span class="err"&gt;都为&lt;/span&gt;&lt;span class="nt"&gt;0&lt;/span&gt;&lt;span class="err"&gt;了&lt;/span&gt;
&lt;span class="nt"&gt;Container&lt;/span&gt; &lt;span class="cp"&gt;[&lt;/span&gt;    &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;setup&lt;/span&gt; &lt;span class="nt"&gt;hostname&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;

&lt;span class="nt"&gt;root&lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="k"&gt;container&lt;/span&gt;&lt;span class="o"&gt;:~&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;id&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;----&lt;/span&gt;&lt;span class="err"&gt;我们可以看到容器里的用户和命令行提示符是&lt;/span&gt;&lt;span class="nt"&gt;root&lt;/span&gt;&lt;span class="err"&gt;用户了&lt;/span&gt;
&lt;span class="nt"&gt;uid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;0&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;root&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nt"&gt;gid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;0&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;root&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nt"&gt;groups&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;0&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;root&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt;&lt;span class="nt"&gt;65534&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;nogroup&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="err"&gt;虽然容器里是&lt;/span&gt;&lt;span class="nt"&gt;root&lt;/span&gt;&lt;span class="err"&gt;，但其实这个容器的&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;bash&lt;/span&gt;&lt;span class="err"&gt;进程是以一个普通用户&lt;/span&gt;&lt;span class="nt"&gt;hchen&lt;/span&gt;&lt;span class="err"&gt;来运行的。这样一来，我们容器的安全性会得到提高。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们注意到，User Namespace是以普通用户运行，但是别的Namespace需要root权限，那么，如果我要同时使用多个Namespace，该怎么办呢？一般来说，我们先用一般用户创建User Namespace，然后把这个一般用户映射成root，在容器内用root来创建其它的Namesapce。&lt;/p&gt;
&lt;h4&gt;Network Namespace&lt;/h4&gt;
&lt;p&gt;Network的Namespace比较啰嗦。在Linux下，我们一般用ip命令创建Network Namespace（Docker的源码中，它没有用ip命令，而是自己实现了ip命令内的一些功能——是用了Raw Socket发些“奇怪”的数据，呵呵）。这里，我还是用ip命令讲解一下。&lt;/p&gt;
&lt;p&gt;首先，我们先看个图，下面这个图基本上就是Docker在宿主机上的网络示意图（其中的物理网卡并不准确，因为docker可能会运行在一个VM中，所以，这里所谓的“物理网卡”其实也就是一个有可以路由的IP的网卡）&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/network.namespace.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;上图中，Docker使用了一个私有网段，172.40.1.0，docker还可能会使用10.0.0.0和192.168.0.0这两个私有网段，关键看你的路由表中是否配置了，如果没有配置，就会使用，如果你的路由表配置了所有私有网段，那么docker启动时就会出错了。&lt;/p&gt;
&lt;p&gt;当你启动一个Docker容器后，你可以使用ip link show或ip addr show来查看当前宿主机的网络情况（我们可以看到有一个docker0，还有一个veth22a38e6的虚拟网卡——给容器用的）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;hchen@ubuntu:~$ ip link show
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state ...
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc ...
    link/ether 00:0c:29:b7:67:7d brd ff:ff:ff:ff:ff:ff
3: docker0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 ...
    link/ether 56:84:7a:fe:97:99 brd ff:ff:ff:ff:ff:ff
5: veth22a38e6: &amp;lt;BROADCAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc ...
    link/ether 8e:30:2a:ac:8c:d1 brd ff:ff:ff:ff:ff:ff
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么，要做成这个样子应该怎么办呢？我们来看一组命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;## 首先，我们先增加一个网桥lxcbr0，模仿docker0
brctl addbr lxcbr0
brctl stp lxcbr0 off
ifconfig lxcbr0 192.168.10.1/24 up #为网桥设置IP地址

## 接下来，我们要创建一个network namespace - ns1

# 增加一个namesapce 命令为 ns1 （使用ip netns add命令）
ip netns add ns1

# 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令）
ip netns exec ns1   ip link set dev lo up

## 然后，我们需要增加一对虚拟网卡

# 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中
ip link add veth-ns1 type veth peer name lxcbr0.1

# 把 veth-ns1 按到namespace ns1中，这样容器中就会有一个新的网卡了
ip link set veth-ns1 netns ns1

# 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了）
ip netns exec ns1  ip link set dev veth-ns1 name eth0

# 为容器中的网卡分配一个IP地址，并激活它
ip netns exec ns1 ifconfig eth0 192.168.10.11/24 up


# 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上
brctl addif lxcbr0 lxcbr0.1

# 为容器增加一个路由规则，让容器可以访问外面的网络
ip netns exec ns1     ip route add default via 192.168.10.1

# 在/etc/netns下创建network namespce名称为ns1的目录，
# 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了
mkdir -p /etc/netns/ns1
echo &amp;quot;nameserver 8.8.8.8&amp;quot; &amp;gt; /etc/netns/ns1/resolv.conf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面基本上就是docker网络的原理了，只不过，&lt;/p&gt;
&lt;p&gt;Docker的resolv.conf没有用这样的方式，而是用了上篇中的Mount Namesapce的那种方式
另外，docker是用进程的PID来做Network Namespace的名称的。
了解了这些后，你甚至可以为正在运行的docker容器增加一个新的网卡：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ip link add peerA type veth peer name peerB
brctl addif docker0 peerA
ip link set peerA up
ip link set peerB netns &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
ip netns exec &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt; ip link set dev peerB name eth1
ip netns exec &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt; ip link set eth1 up ;
ip netns exec &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt; ip addr add &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;ROUTEABLE_IP&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt; dev eth1 ;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的示例是我们为正在运行的docker容器，增加一个eth1的网卡，并给了一个静态的可被外部访问到的IP地址。&lt;/p&gt;
&lt;p&gt;这个需要把外部的“物理网卡”配置成混杂模式，这样这个eth1网卡就会向外通过ARP协议发送自己的Mac地址，然后外部的交换机就会把到这个IP地址的包转到“物理网卡”上，因为是混杂模式，所以eth1就能收到相关的数据，一看，是自己的，那么就收到。这样，Docker容器的网络就和外部通了。&lt;/p&gt;
&lt;p&gt;当然，无论是Docker的NAT方式，还是混杂模式都会有性能上的问题，NAT不用说了，存在一个转发的开销，混杂模式呢，网卡上收到的负载都会完全交给所有的虚拟网卡上，于是就算一个网卡上没有数据，但也会被其它网卡上的数据所影响。&lt;/p&gt;
&lt;p&gt;这两种方式都不够完美，我们知道，真正解决这种网络问题需要使用VLAN技术，于是Google的同学们为Linux内核实现了一个IPVLAN的驱动，这基本上就是为Docker量身定制的。&lt;/p&gt;
&lt;h4&gt;Namespace文件&lt;/h4&gt;
&lt;p&gt;上面就是目前Linux Namespace的玩法。 现在，我来看一下其它的相关东西。&lt;/p&gt;
&lt;p&gt;让我们运行一下上篇中的那个pid.mnt的程序（也就是PID Namespace中那个mount proc的程序），然后不要退出。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo ./pid.mnt
&lt;span class="o"&gt;[&lt;/span&gt;sudo&lt;span class="o"&gt;]&lt;/span&gt; password &lt;span class="k"&gt;for&lt;/span&gt; hchen:
Parent &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="m"&gt;4599&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; - start a container!
Container &lt;span class="o"&gt;[&lt;/span&gt;    &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; - inside the container!
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们到另一个shell中查看一下父子进程的PID：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;hchen@ubuntu:~$ pstree -p 4599
pid.mnt(4599)───bash(4600)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以到proc下（/proc//ns）查看进程的各个namespace的id（内核版本需要3.8以上）。&lt;/p&gt;
&lt;p&gt;下面是父进程的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;hchen@ubuntu:~$ sudo ls -l /proc/4599/ns
total 0
lrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -&amp;gt; ipc:[4026531839]
lrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -&amp;gt; mnt:[4026531840]
lrwxrwxrwx 1 root root 0  4月  7 22:01 net -&amp;gt; net:[4026531956]
lrwxrwxrwx 1 root root 0  4月  7 22:01 pid -&amp;gt; pid:[4026531836]
lrwxrwxrwx 1 root root 0  4月  7 22:01 user -&amp;gt; user:[4026531837]
lrwxrwxrwx 1 root root 0  4月  7 22:01 uts -&amp;gt; uts:[4026531838]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下面是子进程的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;hchen@ubuntu:~$ sudo ls -l /proc/4600/ns
total 0
lrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -&amp;gt; ipc:[4026531839]
lrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -&amp;gt; mnt:[4026532520]
lrwxrwxrwx 1 root root 0  4月  7 22:01 net -&amp;gt; net:[4026531956]
lrwxrwxrwx 1 root root 0  4月  7 22:01 pid -&amp;gt; pid:[4026532522]
lrwxrwxrwx 1 root root 0  4月  7 22:01 user -&amp;gt; user:[4026531837]
lrwxrwxrwx 1 root root 0  4月  7 22:01 uts -&amp;gt; uts:[4026532521]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以看到，其中的ipc，net，user是同一个ID，而mnt,pid,uts都是不一样的。如果两个进程指向的namespace编号相同，就说明他们在同一个namespace下，否则则在不同namespace里面。&lt;/p&gt;
&lt;p&gt;这些文件还有另一个作用，那就是，一旦这些文件被打开，只要其fd被占用着，那么就算PID所属的所有进程都已经结束，创建的namespace也会一直存在。比如：我们可以通过：mount –bind /proc/4600/ns/uts ~/uts 来hold这个namespace。&lt;/p&gt;
&lt;p&gt;另外，我们在上篇中讲过一个setns的系统调用，其函数声明如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int setns(int fd, int nstype);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中第一个参数就是一个fd，也就是一个open()系统调用打开了上述文件后返回的fd，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fd = open(&amp;quot;/proc/4600/ns/nts&amp;quot;, O_RDONLY);  // 获取namespace文件描述符
setns(fd, 0); // 加入新的namespace
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参考文档&lt;/p&gt;
&lt;p&gt;&lt;a href="http://lwn.net/Articles/531114/"&gt;Namespaces in operation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://man7.org/linux/man-pages/man7/namespaces.7.html"&gt;Linux Namespace Man Page&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://crosbymichael.com/creating-containers-part-1.html"&gt;Creat Containers – Part 1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.yadutaf.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/"&gt;Introduction to Linux namespaces&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（全文完）&lt;/p&gt;</summary><category term="Docker"></category></entry><entry><title>Docker基础技术：Linux Namespace（上）</title><link href="http://king32783784.github.io/2016/08/11/Docker/" rel="alternate"></link><published>2016-08-11T00:00:00+08:00</published><updated>2016-08-11T00:00:00+08:00</updated><author><name>others</name></author><id>tag:king32783784.github.io,2016-08-11:2016/08/11/Docker/</id><summary type="html">&lt;p&gt;时下最热的技术莫过于Docker了，很多人都觉得Docker是个新技术，其实不然，Docker除了其编程语言用go比较新外，其实它还真不是个新东西，也就是个新瓶装旧酒的东西，所谓的The New “Old Stuff”。Docker和Docker衍生的东西用到了很多很酷的技术，我会用几篇 文章来把这些技术给大家做个介绍，希望通过这些文章大家可以自己打造一个山寨版的docker。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/PYHO3G128V.jpg" height="280" width="420"&gt;&lt;/p&gt;
&lt;p&gt;当然，文章的风格一定会尊重时下的“流行”——我们再也没有整块整块的时间去看书去专研，而我们只有看微博微信那样的碎片时间（那怕我们有整块的时间，也被那些在手机上的APP碎片化了）。所以，这些文章的风格必然坚持“马桶风格”（希望简单到占用你拉一泡屎就时间，而且你还不用动脑子，并能学到些东西）&lt;/p&gt;
&lt;p&gt;废话少说，我们开始。先从Linux Namespace开始。&lt;/p&gt;
&lt;h4&gt;简介&lt;/h4&gt;
&lt;p&gt;Linux Namespace是Linux提供的一种内核级别环境隔离的方法。不知道你是否还记得很早以前的Unix有一个叫chroot的系统调用（通过修改根目录把用户jail到一个特定目录下），chroot提供了一种简单的隔离模式：chroot内部的文件系统无法访问外部的内容。Linux Namespace在此基础上，提供了对UTS、IPC、mount、PID、network、User等的隔离机制。&lt;/p&gt;
&lt;p&gt;举个例子，我们都知道，Linux下的超级父亲进程的PID是1，所以，同chroot一样，如果我们可以把用户的进程空间jail到某个进程分支下，并像chroot那样让其下面的进程 看到的那个超级父进程的PID为1，于是就可以达到资源隔离的效果了（不同的PID namespace中的进程无法看到彼此）&lt;/p&gt;
&lt;p&gt;Linux Namespace 有如下种类，官方文档在这里&lt;a href="http://lwn.net/Articles/531114/"&gt;《Namespace in Operation》&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分类&lt;/th&gt;
&lt;th&gt;系统调用参数&lt;/th&gt;
&lt;th&gt;相关内核版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Mount namespaces&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;CLONE_NEWNS&lt;/td&gt;
&lt;td&gt;Linux 2.4.19&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;UTS namespaces&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;CLONE_NEWUTS&lt;/td&gt;
&lt;td&gt;Linux 2.6.19&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;IPC namespaces&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;CLONE_NEWIPC&lt;/td&gt;
&lt;td&gt;Linux 2.6.19&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;PID namespaces&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;CLONE_NEWPID&lt;/td&gt;
&lt;td&gt;Linux 2.6.24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Network namespaces&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;CLONE_NEWNET&lt;/td&gt;
&lt;td&gt;始于Linux 2.6.24 完成于 Linux 2.6.29&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;User namespaces&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;CLONE_NEWUSER&lt;/td&gt;
&lt;td&gt;始于 Linux 2.6.23 完成于 Linux 3.8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;主要是三个系统调用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clone() – 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。&lt;/li&gt;
&lt;li&gt;unshare() – 使某进程脱离某个namespace&lt;/li&gt;
&lt;li&gt;setns() – 把某进程加入到某个namespace&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;unshare() 和 setns() 都比较简单，大家可以自己man，我这里不说了。&lt;/p&gt;
&lt;p&gt;下面还是让我们来看一些示例（以下的测试程序最好在Linux 内核为3.8以上的版本中运行，我用的是ubuntu 14.04）。
&lt;strong&gt;clone()系统调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，我们来看一下一个最简单的clone()系统调用的示例，（后面，我们的程序都会基于这个程序做修改）：
 ```c &lt;br /&gt;
    #define _GNU_SOURCE
    #include &lt;sys/types.h&gt;
    #include &lt;sys/wait.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;sched.h&gt;
    #include &lt;signal.h&gt;
    #include &lt;unistd.h&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* 定义一个给 clone 用的栈，栈大小1M */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;define&lt;span class="w"&gt; &lt;/span&gt;STACK_SIZE&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1024&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1024&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
static&lt;span class="w"&gt; &lt;/span&gt;char&lt;span class="w"&gt; &lt;/span&gt;container_stack&lt;span class="err"&gt;[&lt;/span&gt;STACK_SIZE&lt;span class="err"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

char&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;const&lt;span class="w"&gt; &lt;/span&gt;container_args&lt;span class="err"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/bin/bash&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;NULL&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

int&lt;span class="w"&gt; &lt;/span&gt;container_main&lt;span class="o"&gt;(&lt;/span&gt;void&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;arg&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;printf&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Container - inside the container!\n&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;execv&lt;span class="o"&gt;(&lt;/span&gt;container_args&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;container_args&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;printf&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Something&amp;#39;s wrong!\n&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

int&lt;span class="w"&gt; &lt;/span&gt;main&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;printf&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parent - start a container!\n&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/*   调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，     因为栈是反着的） */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;container_pid&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;clone&lt;span class="o"&gt;(&lt;/span&gt;container_main&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;container_stack&lt;span class="o"&gt;+&lt;/span&gt;STACK_SIZE&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;SIGCHLD&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;NULL&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 等待子进程结束 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;waitpid&lt;span class="o"&gt;(&lt;/span&gt;container_pid&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;NULL&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;printf&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parent - container stopped!\n&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;从上面的程序，我们可以看到，这和pthread基本上是一样的玩法。但是，对于上面的程序，父子进程的进程空间是没有什么差别的，父进程能访问到的子进程也能。

下面， 让我们来看几个例子看看，Linux的Namespace是什么样的。

#### UTS Namespace

下面的代码，我略去了上面那些头文件和数据结构的定义，只有最重要的部分。
```c
    int container_main(void* arg)
    {
        printf(&amp;quot;Container - inside the container!\n&amp;quot;);
        sethostname(&amp;quot;container&amp;quot;,10); /* 设置hostname */
        execv(container_args[0], container_args);
        printf(&amp;quot;Something&amp;#39;s wrong!\n&amp;quot;);
        return 1;
    }

    int main()
    {
        printf(&amp;quot;Parent - start a container!\n&amp;quot;);
        int container_pid = clone(container_main, container_stack+STACK_SIZE,
                CLONE_NEWUTS | SIGCHLD, NULL); /*启用CLONE_NEWUTS Namespace隔离 */
        waitpid(container_pid, NULL, 0);
        printf(&amp;quot;Parent - container stopped!\n&amp;quot;);
        return 0;
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行上面的程序你会发现（需要root权限），子进程的hostname变成了 container。
    hchen@ubuntu:~$ sudo ./uts
    Parent - start a container!
    Container - inside the container!
    root@container:~# hostname
    container
    root@container:~# uname -n
    container&lt;/p&gt;
&lt;h4&gt;IPC Namespace&lt;/h4&gt;
&lt;p&gt;IPC全称 Inter-Process Communication，是Unix/Linux下进程间通信的一种方式，IPC有共享内存、信号量、消息队列等方法。所以，为了隔离，我们也需要把IPC给隔离开来，这样，只有在同一个Namespace下的进程才能相互通信。如果你熟悉IPC的原理的话，你会知道，IPC需要有一个全局的ID，即然是全局的，那么就意味着我们的Namespace需要对这个ID隔离，不能让别的Namespace的进程看到。&lt;/p&gt;
&lt;p&gt;要启动IPC隔离，我们只需要在调用clone时加上CLONE_NEWIPC参数就可以了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int container_pid = clone(container_main,     container_stack+STACK_SIZE,
            CLONE_NEWUTS | CLONE_NEWIPC | SIGCHLD, NULL);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;首先，我们先创建一个IPC的Queue（如下所示，全局的Queue ID是0）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;hchen@ubuntu:~$ ipcmk -Q
Message queue id: 0

hchen@ubuntu:~$ ipcs -q
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0xd0d56eb2 0          hchen      644        0            0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果我们运行没有CLONE_NEWIPC的程序，我们会看到，在子进程中还是能看到这个全启的IPC Queue。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;hchen@ubuntu:~$ sudo ./uts
Parent - start a container!
Container - inside the container!

root@container:~# ipcs -q

------ Message Queues --------
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;key        msqid      owner      perms      used-bytes   messages  &lt;br /&gt;
   0xd0d56eb2 0          hchen      644        0            0&lt;/p&gt;
&lt;p&gt;但是，如果我们运行加上了CLONE_NEWIPC的程序，我们就会下面的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@ubuntu:~$ sudo./ipc
Parent - start a container!
Container - inside the container!

root@container:~/linux_namespace# ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以看到IPC已经被隔离了。&lt;/p&gt;
&lt;h4&gt;PID Namespace&lt;/h4&gt;
&lt;p&gt;我们继续修改上面的程序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int container_main(void* arg)
{
    /* 查看子进程的PID，我们可以看到其输出子进程的 pid 为 1 */
    printf(&amp;quot;Container [%5d] - inside the container!\n&amp;quot;, getpid());
    sethostname(&amp;quot;container&amp;quot;,10);
    execv(container_args[0], container_args);
    printf(&amp;quot;Something&amp;#39;s wrong!\n&amp;quot;);
    return 1;
}

int main()
{
    printf(&amp;quot;Parent [%5d] - start a container!\n&amp;quot;, getpid());
    /*启用PID namespace - CLONE_NEWPID*/
    int container_pid = clone(container_main, container_stack+STACK_SIZE,
            CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD, NULL);
    waitpid(container_pid, NULL, 0);
    printf(&amp;quot;Parent - container stopped!\n&amp;quot;);
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行结果如下（我们可以看到，子进程的pid是1了）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;hchen@ubuntu:~$ sudo ./pid
Parent [ 3474] - start a container!
Container [    1] - inside the container!
root@container:~# echo $$
1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你可能会问，PID为1有个毛用啊？我们知道，在传统的UNIX系统中，PID为1的进程是init，地位非常特殊。他作为所有进程的父进程，有很多特权（比如：屏蔽信号等），另外，其还会为检查所有进程的状态，我们知道，如果某个子进程脱离了父进程（父进程没有wait它），那么init就会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建出PID为1的进程，最好就像chroot那样，把子进程的PID在容器内变成1。&lt;/p&gt;
&lt;p&gt;但是，我们会发现，在子进程的shell里输入ps,top等命令，我们还是可以看得到所有进程。说明并没有完全隔离。这是因为，像ps, top这些命令会去读/proc文件系统，所以，因为/proc文件系统在父进程和子进程都是一样的，所以这些命令显示的东西都是一样的。&lt;/p&gt;
&lt;p&gt;所以，我们还需要对文件系统进行隔离。&lt;/p&gt;
&lt;h4&gt;Mount Namespace&lt;/h4&gt;
&lt;p&gt;下面的例程中，我们在启用了mount namespace并在子进程中重新mount了/proc文件系统。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int container_main(void* arg)
{
    printf(&amp;quot;Container [%5d] - inside the container!\n&amp;quot;, getpid());
    sethostname(&amp;quot;container&amp;quot;,10);
    /* 重新mount proc文件系统到 /proc下 */
    system(&amp;quot;mount -t proc proc /proc&amp;quot;);
    execv(container_args[0], container_args);
    printf(&amp;quot;Something&amp;#39;s wrong!\n&amp;quot;);
    return 1;
}

int main()
{
    printf(&amp;quot;Parent [%5d] - start a container!\n&amp;quot;, getpid());
    /* 启用Mount Namespace - 增加CLONE_NEWNS参数 */
    int container_pid = clone(container_main, container_stack+STACK_SIZE,
            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL);
    waitpid(container_pid, NULL, 0);
    printf(&amp;quot;Parent - container stopped!\n&amp;quot;);
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;hchen@ubuntu:~$ sudo ./pid.mnt
Parent [ 3502] - start a container!
Container [    1] - inside the container!
root@container:~# ps -elf
F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
4 S root         1     0  0  80   0 -  6917 wait   19:55 pts/2    00:00:00 /bin/bash
0 R root        14     1  0  80   0 -  5671 -      19:56 pts/2    00:00:00 ps -elf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面，我们可以看到只有两个进程 ，而且pid=1的进程是我们的/bin/bash。我们还可以看到/proc目录下也干净了很多：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@container:~# ls /proc
1          dma          key-users   net            sysvipc
16         driver       kmsg        pagetypeinfo   timer_list
acpi       execdomains  kpagecount  partitions     timer_stats
asound     fb           kpageflags  sched_debug    tty
buddyinfo  filesystems  loadavg     schedstat      uptime
bus        fs           locks       scsi           version
cgroups    interrupts   mdstat      self           version_signature
cmdline    iomem        meminfo     slabinfo       vmallocinfo
consoles   ioports      misc        softirqs       vmstat
cpuinfo    irq          modules     stat           zoneinfo
crypto     kallsyms     mounts      swaps
devices    kcore        mpt         sys
diskstats  keys         mtrr        sysrq-trigger
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里，多说一下。在通过CLONE_NEWNS创建mount namespace后，父进程会把自己的文件结构复制给子进程中。而子进程中新的namespace中的所有mount操作都只影响自身的文件系统，而不对外界产生任何影响。这样可以做到比较严格地隔离。&lt;/p&gt;
&lt;p&gt;你可能会问，我们是不是还有别的一些文件系统也需要这样mount? 是的。
Docker的 Mount Namespace&lt;/p&gt;
&lt;p&gt;下面我将向演示一个“山寨镜像”，其模仿了Docker的Mount Namespace。&lt;/p&gt;
&lt;p&gt;首先，我们需要一个rootfs，也就是我们需要把我们要做的镜像中的那些命令什么的copy到一个rootfs的目录下，我们模仿Linux构建如下的目录：
    hchen@ubuntu:~/rootfs$ ls
    bin  dev  etc  home  lib  lib64  mnt  opt  proc  root  run  sbin  sys  tmp  usr  var&lt;/p&gt;
&lt;p&gt;然后，我们把一些我们需要的命令copy到 rootfs/bin目录中（sh命令必需要copy进去，不然我们无法 chroot ）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;hchen@ubuntu:~/rootfs$ ls ./bin ./usr/bin

./bin:
bash   chown  gzip      less  mount       netstat  rm     tabs  tee      top       tty
cat    cp     hostname  ln    mountpoint  ping     sed    tac   test     touch     umount
chgrp  echo   ip        ls    mv          ps       sh     tail  timeout  tr        uname
chmod  grep   kill      more  nc          pwd      sleep  tar   toe      truncate  which

./usr/bin:
awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;注：你可以使用ldd命令把这些命令相关的那些so文件copy到对应的目录：&lt;/p&gt;
&lt;p&gt;hchen@ubuntu:~/rootfs/bin$ ldd bash
    linux-vdso.so.1 =&amp;gt;  (0x00007fffd33fc000)
    libtinfo.so.5 =&amp;gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f4bd42c2000)
    libdl.so.2 =&amp;gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4bd40be000)
    libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4bd3cf8000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f4bd4504000)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是我的rootfs中的一些so文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;hchen@ubuntu:~/rootfs$ ls ./lib64 ./lib/x86_64-linux-gnu/

./lib64:
ld-linux-x86-64.so.2

./lib/x86_64-linux-gnu/:
libacl.so.1      libmemusage.so         libnss_files-2.19.so    libpython3.4m.so.1
libacl.so.1.1.0  libmount.so.1          libnss_files.so.2       libpython3.4m.so.1.0
libattr.so.1     libmount.so.1.1.0      libnss_hesiod-2.19.so   libresolv-2.19.so
libblkid.so.1    libm.so.6              libnss_hesiod.so.2      libresolv.so.2
libc-2.19.so     libncurses.so.5        libnss_nis-2.19.so      libselinux.so.1
libcap.a         libncurses.so.5.9      libnss_nisplus-2.19.so  libtinfo.so.5
libcap.so        libncursesw.so.5       libnss_nisplus.so.2     libtinfo.so.5.9
libcap.so.2      libncursesw.so.5.9     libnss_nis.so.2         libutil-2.19.so
libcap.so.2.24   libnsl-2.19.so         libpcre.so.3            libutil.so.1
libc.so.6        libnsl.so.1            libprocps.so.3          libuuid.so.1
libdl-2.19.so    libnss_compat-2.19.so  libpthread-2.19.so      libz.so.1
libdl.so.2       libnss_compat.so.2     libpthread.so.0
libgpm.so.2      libnss_dns-2.19.so     libpython2.7.so.1
libm-2.19.so     libnss_dns.so.2        libpython2.7.so.1.0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;包括这些命令依赖的一些配置文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;hchen@ubuntu:~/rootfs$ ls ./etc
bash.bashrc  group  hostname  hosts  ld.so.cache  nsswitch.conf  passwd  profile  
resolv.conf  shadow
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你现在会说，我靠，有些配置我希望是在容器起动时给他设置的，而不是hard code在镜像中的。比如：/etc/hosts，/etc/hostname，还有DNS的/etc/resolv.conf文件。好的。那我们在rootfs外面，我们再创建一个conf目录，把这些文件放到这个目录中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;hchen@ubuntu:~$ ls ./conf
hostname     hosts     resolv.conf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，我们的父进程就可以动态地设置容器需要的这些文件的配置， 然后再把他们mount进容器，这样，容器的镜像中的配置就比较灵活了。&lt;/p&gt;
&lt;p&gt;好了，终于到了我们的程序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define _GNU_SOURCE&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sys/mount.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;sched.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#define STACK_SIZE (1024 * 1024)&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;container_stack&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;STACK_SIZE&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;container_args&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;/bin/bash&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;-l&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nb"&gt;NULL&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;container_main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Container [%5d] - inside the container!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;getpid&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="c1"&gt;//set hostname&lt;/span&gt;
    &lt;span class="n"&gt;sethostname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;container&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;//remount &amp;quot;/proc&amp;quot; to make sure the &amp;quot;top&amp;quot; and &amp;quot;ps&amp;quot; show container&amp;#39;s information&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;proc&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;rootfs/proc&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;proc&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;proc&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sysfs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;rootfs/sys&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;sysfs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sys&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;none&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;rootfs/tmp&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;tmpfs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tmp&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;udev&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;rootfs/dev&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;devtmpfs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;dev&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;devpts&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;rootfs/dev/pts&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;devpts&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;dev/pts&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;shm&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;rootfs/dev/shm&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;tmpfs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;dev/shm&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tmpfs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;rootfs/run&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;tmpfs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;run&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * 模仿Docker的从外向容器里mount相关的配置文件&lt;/span&gt;
&lt;span class="cm"&gt;     * 你可以查看：/var/lib/docker/containers/&amp;lt;container_id&amp;gt;/目录，&lt;/span&gt;
&lt;span class="cm"&gt;     * 你会看到docker的这些文件的。&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;conf/hosts&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;rootfs/etc/hosts&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;none&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MS_BIND&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;
          &lt;span class="n"&gt;mount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;conf/hostname&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;rootfs/etc/hostname&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;none&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MS_BIND&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;
          &lt;span class="n"&gt;mount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;conf/resolv.conf&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;rootfs/etc/resolv.conf&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;none&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MS_BIND&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;conf&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="cm"&gt;/* 模仿docker run命令中的 -v, --volume=[] 参数干的事 */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/tmp/t1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;rootfs/mnt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;none&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MS_BIND&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
         &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mnt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* chroot 隔离目录 */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;chdir&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;./rootfs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;chroot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;./&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;chdir/chroot&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;execv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;container_args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;container_args&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;exec&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Something&amp;#39;s wrong!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parent [%5d] - start a container!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;getpid&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;container_pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;container_main&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;container_stack&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;STACK_SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;CLONE_NEWUTS&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;CLONE_NEWIPC&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;CLONE_NEWPID&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;CLONE_NEWNS&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;SIGCHLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;waitpid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;container_pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parent - container stopped!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;sudo运行上面的程序，你会看到下面的挂载信息以及一个所谓的“镜像”：
    hchen@ubuntu:~$ sudo ./mount
    Parent [ 4517] - start a container!
    Container [    1] - inside the container!
    root@container:/# mount
    proc on /proc type proc (rw,relatime)
    sysfs on /sys type sysfs (rw,relatime)
    none on /tmp type tmpfs (rw,relatime)
    udev on /dev type devtmpfs (rw,relatime,size=493976k,nr_inodes=123494,mode=755)
    devpts on /dev/pts type devpts (rw,relatime,mode=600,ptmxmode=000)
    tmpfs on /run type tmpfs (rw,relatime)
    /dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hosts type ext4 (rw,relatime,errors=remount-ro,data=ordered)
    /dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hostname type ext4 (rw,relatime,errors=remount-ro,data=ordered)
    /dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/resolv.conf type ext4 (rw,relatime,errors=remount-ro,data=ordered)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@container:/# ls /bin /usr/bin
/bin:
bash   chmod  echo  hostname  less  more    mv   ping  rm   sleep  tail  test     top    truncate  uname
cat    chown  grep  ip        ln    mount   nc   ps    sed  tabs   tar   timeout  touch  tty       which
chgrp  cp     gzip  kill      ls    mountpoint  netstat  pwd   sh   tac    tee   toe      tr     umount

/usr/bin:
awk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关于如何做一个chroot的目录，这里有个工具叫&lt;a href="https://wiki.ubuntu.com/DebootstrapChroot"&gt;DebootstrapChroot&lt;/a&gt;，你可以顺着链接去看看（英文的哦）&lt;/p&gt;
&lt;p&gt;接下来的事情，你可以自己玩了，我相信你的想像力 。：）&lt;/p&gt;
&lt;p&gt;在下一篇，我将向你介绍User Namespace、Network Namespace以及Namespace的其它东西。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vimlinux.com/2016/08/12/Docker/"&gt;Docker基础技术：Linux Namespace（下)&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（上篇完，请参看下篇）&lt;/p&gt;</summary><category term="Docker"></category></entry><entry><title>如何做性能测试</title><link href="http://king32783784.github.io/2016/08/11/Performance/" rel="alternate"></link><published>2016-08-11T00:00:00+08:00</published><updated>2016-08-11T00:00:00+08:00</updated><author><name>others</name></author><id>tag:king32783784.github.io,2016-08-11:2016/08/11/Performance/</id><summary type="html">&lt;p&gt;偶然间看到了阿里中间件Dubbo的性能测试报告，我觉得这份性能测试报告让人觉得做这性能测试的人根本不懂性能测试，我觉得这份报告会把大众带沟里去，所以，想写下这篇文章，做一点科普。&lt;/p&gt;
&lt;p&gt;首先，这份测试报告里的主要问题如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用的全是平均值。老实说，平均值是非常不靠谱的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应时间没有和吞吐量TPS/QPS挂钩。而只是测试了低速率的情况，这是完全错误的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应时间和吞吐量没有和成功率挂钩。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;为什么平均值不靠谱&lt;/h4&gt;
&lt;p&gt;关于平均值为什么不靠谱，我相信大家读新闻的时候经常可以看到，&lt;strong&gt;平均工资&lt;/strong&gt;，&lt;strong&gt;平均房价&lt;/strong&gt;，&lt;strong&gt;平均支出&lt;/strong&gt;，等等这样的字眼，你就知道为什么平均值不靠谱了。（这些都是数学游戏，对于理工科的同学来说，天生应该有免疫力）&lt;/p&gt;
&lt;p&gt;软件的性能测试也一样，平均数也是不靠谱的，这里可以参看这篇详细的文章《Why Averages Suck and Percentiles are Great》，我在这里简单说一下。&lt;/p&gt;
&lt;p&gt;我们知道，性能测试时，测试得到的结果数据不总是一样的，而是有高有低的，如果算平均值就会出现这样的情况，假如，&lt;strong&gt;测试了10次，有9次是1ms，而有1次是1s，那么平均数据就是100ms，很明显，这完全不能反应性能测试的情况，也许那1s的请求就是一个不正常的值，是个噪点，应该去掉。&lt;/strong&gt; 所以，我们会在一些评委打分中看到要去掉一个最高分一个最低分，然后再算平均值。&lt;/p&gt;
&lt;p&gt;另外，中位数（Mean）可能会比平均数要稍微靠谱一些，所谓中位数的意就是把将一组数据按大小顺序排列，处在最中间位置的一个数叫做这组数据的中位数 ，这意味着至少有50%的数据低于或高于这个中位数。&lt;/p&gt;
&lt;p&gt;当然，最为正确的统计做法是用百分比分布统计。也就是英文中的&lt;strong&gt;TP – Top Percentile&lt;/strong&gt; ，TP50的意思在，50%的请求都小于某个值，TP90表示90%的请求小于某个时间。&lt;/p&gt;
&lt;p&gt;比如：我们有一组数据：[ 10ms,  1s, 200ms, 100ms]，我们把其从小到大排个序：[10ms, 100ms, 200ms, 1s]，于是我们知道，TP50，就是50%的请求ceil(4&lt;em&gt;0.5)=2时间是小于100ms的，TP90就是90%的请求ceil(4&lt;/em&gt;0.9)=4时间小于1s。于是：TP50就是100ms，TP90就是1s。&lt;/p&gt;
&lt;p&gt;我以前在路透做的金融系统响应时间的性能测试的要求是这样的，&lt;strong&gt;99.9%的请求必须小于1ms，所有的平均时间必须小于1ms。两个条件的限制。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;为什么响应时间（latency）要和吞吐量（Thoughput）挂钩&lt;/h4&gt;
&lt;p&gt;系统的性能如果只看吞吐量，不看响应时间是没有意义的。我的系统可以顶10万请求，但是响应时间已经到了5秒钟，这样的系统已经不可用了，这样的吞吐量也是没有意义的。&lt;/p&gt;
&lt;p&gt;我们知道，当并发量（吞吐量）上涨的时候，系统会变得越来越不稳定，响应时间的波动也会越来越大，响应时间也会变得越来越慢，而吞吐率也越来越上不去（如下图所示），包括CPU的使用率情况也会如此。所以，当系统变得不稳定的时候，吞吐量已经没有意义了。吞吐量有意义的时候仅当系统稳定的时候。
&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/BenchmarkOptimalRate.png" /&gt;&lt;/p&gt;
&lt;h4&gt;BenchmarkOptimalRate&lt;/h4&gt;
&lt;p&gt;所以，吞吐量的值必需有响应时间来卡。比如：TP99小于100ms的时候，系统可以承载的最大并发数是1000qps。这意味着，我们要不断的在不同的并发数上测试，以找到软件的最稳定时的最大吞吐量。&lt;/p&gt;
&lt;h4&gt;为什么响应时间吞吐量和成功率要挂钩&lt;/h4&gt;
&lt;p&gt;我们这应该不难理解了，如果请求不成功的话，都还做毛的性能测试。比如，我说我的系统并发可以达到10万，但是失败率是&lt;/p&gt;
&lt;p&gt;40%，那么，这10万的并发完全就是一个笑话了。&lt;/p&gt;
&lt;p&gt;性能测试的失败率的容忍应该是非常低的。对于一些关键系统，成功请求数必须在100%，一点都不能含糊。&lt;/p&gt;
&lt;h4&gt;如何严谨地做性能测试&lt;/h4&gt;
&lt;p&gt;一般来说，性能测试要统一考虑这么几个因素：&lt;strong&gt;Thoughput吞吐量，Latency响应时间，资源利用&lt;/strong&gt;（CPU/MEM/IO/Bandwidth…），&lt;strong&gt;成功率，系统稳定性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面的这些性能测试的方式基本上来源自我的老老东家汤森路透，一家做real-time的金融数据系统的公司。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一，你得定义一个系统的响应时间latency，建议是TP99，以及成功率。&lt;/strong&gt;
比如路透的定义：99.9%的响应时间必需在1ms之内，平均响应时间在1ms以内，100%的请求成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二，在这个响应时间的限制下，找到最高的吞吐量。&lt;/strong&gt;
测试用的数据，需要有大中小各种尺寸的数据，并可以混合。最好使用生产线上的测试数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三，在这个吞吐量做Soak Test，比如：使用第二步测试得到的吞吐量连续7天的不间断的压测系统。&lt;/strong&gt;
然后收集CPU，内存，硬盘/网络IO，等指标，查看系统是否稳定，比如，CPU是平稳的，内存使用也是平稳的。那么，这个值就是系统的性能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四，找到系统的极限值。比如：在成功率100%的情况下（不考虑响应时间的长短），系统能坚持10分钟的吞吐量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五，做Burst Test。用第二步得到的吞吐量执行5分钟，然后在第四步得到的极限值执行1分钟，再回到第二步的吞吐量执行5钟，再到第四步的权限值执行1分钟，如此往复个一段时间，比如2天。&lt;/strong&gt;
收集系统数据：CPU、内存、硬盘/网络IO等，观察他们的曲线，以及相应的响应时间，确保系统是稳定的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、低吞吐量和网络小包的测试。&lt;/strong&gt;
有时候，在低吞吐量的时候，可能会导致latency上升，比如TCP_NODELAY的参数没有开启会导致latency上升（详见TCP的那些事），而网络小包会导致带宽用不满也会导致性能上不去，所以，性能测试还需要根据实际情况有选择的测试一下这两咱场景。&lt;/p&gt;
&lt;p&gt;（注：在路透，路透会用第二步得到的吞吐量乘以66.7%来做为系统的软报警线，80%做为系统的硬报警线，而极限值仅仅用来扛突发的peak）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是不是很繁锁？是的，只因为，这是工程，工程是一门科学，科学是严谨的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;欢迎大家也分享一下你们性能测试的经验和方法。&lt;/p&gt;
&lt;p&gt;（全文完）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（本文来源于酷 壳 – CoolShell.cn ，请勿用于任何商业用途）&lt;/em&gt;&lt;/p&gt;</summary><category term="性能测试"></category></entry><entry><title>Makefile中文手册</title><link href="http://king32783784.github.io/2013/08/01/Makefile/" rel="alternate"></link><published>2013-08-01T00:00:00+08:00</published><updated>2013-08-01T00:00:00+08:00</updated><author><name>others</name></author><id>tag:king32783784.github.io,2013-08-01:2013/08/01/Makefile/</id><summary type="html">&lt;h4&gt;一 概述&lt;/h4&gt;
&lt;p&gt;什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和 professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。&lt;/p&gt;
&lt;p&gt;因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。&lt;/p&gt;
&lt;p&gt;makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。&lt;/p&gt;
&lt;p&gt;现在讲述如何写 makefile的文章比较少，这是我想写这篇文章的原因。当然，不同厂商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat Linux 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。&lt;/p&gt;
&lt;p&gt;在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。&lt;/p&gt;
&lt;p&gt;关于程序的编译和链接
在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。&lt;/p&gt;
&lt;p&gt;编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。&lt;/p&gt;
&lt;p&gt;链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。&lt;/p&gt;
&lt;p&gt;总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File.&lt;/p&gt;
&lt;p&gt;好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。&lt;/p&gt;
&lt;p&gt;Makefile介绍
make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。&lt;/p&gt;
&lt;p&gt;首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感性认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：&lt;/p&gt;
&lt;p&gt;1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。&lt;/p&gt;
&lt;p&gt;2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。&lt;/p&gt;
&lt;p&gt;3）如果这个工程的头文件被改变了，那么我们需要编译引用了这个头文件的所有C文件，并链接目标程序。&lt;/p&gt;
&lt;p&gt;只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。&lt;/p&gt;
&lt;h4&gt;二、Makefile的规则&lt;/h4&gt;
&lt;p&gt;在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。&lt;/p&gt;
&lt;p&gt;target ... : prerequisites ...&lt;/p&gt;
&lt;p&gt;command&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;target&lt;/strong&gt; 也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;prerequisites&lt;/strong&gt; 就是，要生成那个target所需要的文件或是目标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;command&lt;/strong&gt; 也就是make需要执行的命令。（任意的Shell命令）&lt;/p&gt;
&lt;p&gt;这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是 Makefile的规则。也就是Makefile中最核心的内容。&lt;/p&gt;
&lt;p&gt;说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）&lt;/p&gt;
&lt;h4&gt;三、一个示例&lt;/h4&gt;
&lt;p&gt;正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;edit&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;kbd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;display&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;utils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt;

&lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;edit&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;kbd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;display&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;utils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt;

&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt; &lt;span class="n"&gt;defs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;h&lt;/span&gt;

&lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt;

&lt;span class="n"&gt;kbd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;kbd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt; &lt;span class="n"&gt;defs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;h&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;h&lt;/span&gt;

&lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;kbd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt;

&lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt; &lt;span class="n"&gt;defs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;h&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;h&lt;/span&gt;

&lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt;

&lt;span class="n"&gt;display&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;display&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt; &lt;span class="n"&gt;defs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;h&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;h&lt;/span&gt;

&lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;display&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt;

&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt; &lt;span class="n"&gt;defs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;h&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;h&lt;/span&gt;

&lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt;

&lt;span class="n"&gt;search&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt; &lt;span class="n"&gt;defs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;h&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;h&lt;/span&gt;

&lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt;

&lt;span class="n"&gt;files&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt; &lt;span class="n"&gt;defs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;h&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;h&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;h&lt;/span&gt;

&lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt;

&lt;span class="n"&gt;utils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;utils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt; &lt;span class="n"&gt;defs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;h&lt;/span&gt;

&lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;utils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt;

&lt;span class="n"&gt;clean&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;

&lt;span class="n"&gt;rm&lt;/span&gt; &lt;span class="n"&gt;edit&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;kbd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;display&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;utils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;换行可使用反斜杠（\）。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“make clean”就可以了。&lt;/p&gt;
&lt;p&gt;在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。&lt;/p&gt;
&lt;p&gt;在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。&lt;/p&gt;
&lt;p&gt;这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。&lt;/p&gt;
&lt;h4&gt;四、make是如何工作的&lt;/h4&gt;
&lt;p&gt;在默认的方式下，也就是我们只输入make命令。那么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、make会在当前目录下找名字叫“Makefile”或“makefile”的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3、如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4、如果edit所依赖的.o文件也不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5、当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生命make的终极任务，也就是执行文件edit了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。&lt;/p&gt;
&lt;p&gt;通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。&lt;/p&gt;
&lt;p&gt;于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。&lt;/p&gt;
&lt;p&gt;而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。&lt;/p&gt;
&lt;h4&gt;五、makefile中使用变量&lt;/h4&gt;
&lt;p&gt;在上面的例子中，先让我们看看edit的规则：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;edit&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;kbd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;display&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;utils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt;

&lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;edit&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;kbd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;display&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;utils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在 clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成 C语言中的宏可能会更好。&lt;/p&gt;
&lt;p&gt;比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;于是，我们就可以很方便地在我们的makefile中以“$(objects)”的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o

edit : $(objects)

cc -o edit $(objects)

main.o : main.c defs.h

cc -c main.c

kbd.o : kbd.c defs.h command.h

cc -c kbd.c

command.o : command.c defs.h command.h

cc -c command.c

display.o : display.c defs.h buffer.h

cc -c display.c

insert.o : insert.c defs.h buffer.h

cc -c insert.c

search.o : search.c defs.h buffer.h

cc -c search.c

files.o : files.c defs.h buffer.h command.h

cc -c files.c

utils.o : utils.c defs.h

cc -c utils.c

clean :

rm edit $(objects)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。&lt;/p&gt;
&lt;p&gt;关于变量更多的话题，我会在后续给你一一道来。&lt;/p&gt;
&lt;h4&gt;六、让make自动推导&lt;/h4&gt;
&lt;p&gt;GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。&lt;/p&gt;
&lt;p&gt;只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o

edit : $(objects)

cc -o edit $(objects)

main.o : defs.h

kbd.o : defs.h command.h

command.o : defs.h command.h

display.o : defs.h buffer.h

insert.o : defs.h buffer.h

search.o : defs.h buffer.h

files.o : defs.h buffer.h command.h

utils.o : defs.h

.PHONY : clean

clean :

rm edit $(objects)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。&lt;/p&gt;
&lt;p&gt;关于更为详细的“隐晦规则”和“伪目标文件”，我会在后续给你一一道来。&lt;/p&gt;
&lt;h4&gt;七、另类风格的makefile&lt;/h4&gt;
&lt;p&gt;即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o

edit : $(objects)

cc -o edit $(objects)

$(objects) : defs.h

kbd.o command.o files.o : command.h

display.o insert.o search.o files.o : buffer.h

.PHONY : clean

clean :

rm edit $(objects)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。&lt;/p&gt;
&lt;h4&gt;八、清空目标文件的规则&lt;/h4&gt;
&lt;p&gt;每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;clean&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;

&lt;span class="n"&gt;rm&lt;/span&gt; &lt;span class="n"&gt;edit&lt;/span&gt; &lt;span class="n"&gt;$&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;更为稳健的做法是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="na"&gt;.PHONY&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;clean&lt;/span&gt;

&lt;span class="nf"&gt;clean&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;

&lt;span class="err"&gt;-&lt;/span&gt;&lt;span class="nf"&gt;rm&lt;/span&gt; &lt;span class="no"&gt;edit&lt;/span&gt; &lt;span class="no"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;objects&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。&lt;/p&gt;
&lt;p&gt;上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。&lt;/p&gt;
&lt;h4&gt;九、Makefile总述&lt;/h4&gt;
&lt;h5&gt;1、Makefile里有什么&lt;/h5&gt;
&lt;p&gt;Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3、变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4、文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5、注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“#”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。&lt;/p&gt;
&lt;h5&gt;2、Makefile的文件名&lt;/h5&gt;
&lt;p&gt;默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用 “GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。&lt;/p&gt;
&lt;p&gt;当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“- f”和“--file”参数，如：make -f Make.Linux或make --file Make.AIX。&lt;/p&gt;
&lt;h5&gt;3、引用其它的Makefile&lt;/h5&gt;
&lt;p&gt;在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;include &amp;lt;filename&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）&lt;/p&gt;
&lt;p&gt;在 include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和&lt;filename&gt;可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和 f.mk，那么，下面的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;include foo.make *.mk $(bar)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;等价于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;include foo.make a.mk b.mk c.mk e.mk f.mk
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;make 命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、如果make执行时，有“-I”或“--include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、如果目录&lt;prefix&gt;/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在 include前加一个减号“-”。如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-include &amp;lt;filename&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。&lt;/p&gt;
&lt;h5&gt;4、环境变量 MAKEFILES&lt;/h5&gt;
&lt;p&gt;如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的 Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。&lt;/p&gt;
&lt;p&gt;但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的 Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。&lt;/p&gt;
&lt;h5&gt;5、make的工作方式&lt;/h5&gt;
&lt;p&gt;GNU的make工作时的执行步骤入下：（想来其它的make也是类似）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、读入所有的Makefile。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、读入被include的其它Makefile。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3、初始化文件中的变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4、推导隐晦规则，并分析所有规则。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5、为所有的目标文件创建依赖关系链。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;6、根据依赖关系，决定哪些目标要重新生成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;7、执行生成命令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1-5 步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。&lt;/p&gt;
&lt;p&gt;当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。&lt;/p&gt;
&lt;h4&gt;十、书写规则&lt;/h4&gt;
&lt;p&gt;规则包含两个部分，一个是依赖关系，一个是生成目标的方法。&lt;/p&gt;
&lt;p&gt;在 Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让 make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。&lt;/p&gt;
&lt;p&gt;好了，还是让我们来看一看如何书写规则。&lt;/p&gt;
&lt;h5&gt;1、规则举例&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;foo.o : foo.c defs.h # foo模块

cc -c -g foo.c
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令“cc -c -g foo.c”（以Tab键开头）。这个规则告诉我们两件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;2、规则的语法&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;targets&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;prerequisites&lt;/span&gt;

&lt;span class="n"&gt;command&lt;/span&gt;

&lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或是这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;targets&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;prerequisites&lt;/span&gt; &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;

&lt;span class="n"&gt;command&lt;/span&gt;

&lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。&lt;/p&gt;
&lt;p&gt;command是命令行，如果其不与“target吐舌rerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。&lt;/p&gt;
&lt;p&gt;如果命令太长，你可以使用反斜框（‘\’）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何成成目标文件。&lt;/p&gt;
&lt;p&gt;一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。&lt;/p&gt;
&lt;h5&gt;3、在规则中使用通配符&lt;/h5&gt;
&lt;p&gt;如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：“*”，“?”和“[...]”。这是和Unix的B-Shell是相同的。&lt;/p&gt;
&lt;p&gt;波浪号（“~”）字符在文件名中也有比较特殊的用途。如果是“~/test”，这就表示当前用户的$HOME目录下的test目录。而“~hchen /test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS 下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。&lt;/p&gt;
&lt;p&gt;通配符代替了你一系列的文件，如“&lt;em&gt;.c”表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：“&lt;/em&gt;”，那么可以用转义字符“\”，如“*”来表示真实的“*”字符，而不是任意长度的字符串。&lt;/p&gt;
&lt;p&gt;好吧，还是先来看几个例子吧：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;clean&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;

&lt;span class="n"&gt;rm&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;*.&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print: *.c

lpr -p $?

touch print
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的“$?”是一个自动化变量，我会在后面给你讲述。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;objects = *.o
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面这个例子，表示了，通符同样可以用在变量中。并不是说[&lt;em&gt;.o]会展开，不！objects的值就是“&lt;/em&gt;.o”。Makefile中的变量其实就是 C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;objects := $(wildcard *.o)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种用法由关键字“wildcard”指出，关于Makefile的关键字，我们将在后面讨论。&lt;/p&gt;
&lt;h5&gt;4、文件搜寻&lt;/h5&gt;
&lt;p&gt;在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。&lt;/p&gt;
&lt;p&gt;Makefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;VPATH = src:../headers
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）&lt;/p&gt;
&lt;p&gt;另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个 VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、vpath &lt;pattern&gt; &lt;directories&gt;为符合模式&lt;pattern&gt;的文件指定搜索目录&lt;directories&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、vpath &lt;pattern&gt;清除符合模式&lt;pattern&gt;的文件的搜索目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3、vpath清除所有已被设置好了的文件搜索目录。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;vapth 使用方法中的&lt;pattern&gt;需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。&lt;pattern&gt;指定了要搜索的文件集，而&lt;directories&gt;则指定了&lt;pattern&gt;的文件集的搜索的目录。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vpath %.h ../headers
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的&lt;pattern&gt;，或是被重复了的&lt;pattern&gt;，那么，make会按照vpath语句的先后顺序来执行搜索。如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vpath %.c foo

vpath % blish

vpath %.c bar
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vpath %.c foo:bar

vpath % blish
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。&lt;/p&gt;
&lt;h5&gt;5、伪目标&lt;/h5&gt;
&lt;p&gt;最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;clean&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;

&lt;span class="n"&gt;rm&lt;/span&gt; &lt;span class="o"&gt;*.&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正像我们前面例子中的“clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。（以“make clean”来使用该目标）因为，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。&lt;/p&gt;
&lt;p&gt;当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="na"&gt;.PHONY&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;clean&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;.PHONY:&lt;/span&gt; &lt;span class="nf"&gt;clean&lt;/span&gt;

&lt;span class="nl"&gt;clean:&lt;/span&gt;

&lt;span class="nf"&gt;rm&lt;/span&gt; &lt;span class="p"&gt;*.&lt;/span&gt;&lt;span class="no"&gt;o&lt;/span&gt; &lt;span class="no"&gt;temp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的 Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;all&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;prog1&lt;/span&gt; &lt;span class="n"&gt;prog2&lt;/span&gt; &lt;span class="n"&gt;prog3&lt;/span&gt;

&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;PHONY&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;all&lt;/span&gt;

&lt;span class="n"&gt;prog1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;prog1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;utils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt;

&lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;prog1&lt;/span&gt; &lt;span class="n"&gt;prog1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;utils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt;

&lt;span class="n"&gt;prog2&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;prog2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt;

&lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;prog2&lt;/span&gt; &lt;span class="n"&gt;prog2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt;

&lt;span class="n"&gt;prog3&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;prog3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;utils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt;

&lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;prog3&lt;/span&gt; &lt;span class="n"&gt;prog3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;utils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。 “.PHONY : all”声明了“all”这个目标为“伪目标”。&lt;/p&gt;
&lt;p&gt;随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;.PHONY:&lt;/span&gt; &lt;span class="nf"&gt;cleanall&lt;/span&gt; &lt;span class="no"&gt;cleanobj&lt;/span&gt; &lt;span class="no"&gt;cleandiff&lt;/span&gt;

&lt;span class="nf"&gt;cleanall&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;cleanobj&lt;/span&gt; &lt;span class="no"&gt;cleandiff&lt;/span&gt;

&lt;span class="nf"&gt;rm&lt;/span&gt; &lt;span class="no"&gt;program&lt;/span&gt;

&lt;span class="nf"&gt;cleanobj&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;

&lt;span class="nf"&gt;rm&lt;/span&gt; &lt;span class="p"&gt;*.&lt;/span&gt;&lt;span class="no"&gt;o&lt;/span&gt;

&lt;span class="nf"&gt;cleandiff&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;

&lt;span class="nf"&gt;rm&lt;/span&gt; &lt;span class="p"&gt;*.&lt;/span&gt;&lt;span class="no"&gt;diff&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;“make clean”将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。&lt;/p&gt;
&lt;h5&gt;6、多目标&lt;/h5&gt;
&lt;p&gt;Makefile 的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bigoutput littleoutput : text.g

generate text.g -$(subst output,,$@) &amp;gt; $@
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述规则等价于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;bigoutput&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;g&lt;/span&gt;

&lt;span class="n"&gt;generate&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;g&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;big&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;bigoutput&lt;/span&gt;

&lt;span class="n"&gt;littleoutput&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;g&lt;/span&gt;

&lt;span class="n"&gt;generate&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;g&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;little&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;littleoutput&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，-&lt;span class="math"&gt;\((subst output,,\)&lt;/span&gt;@)中的“&lt;span class="math"&gt;\(”表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“\)&lt;/span&gt;@”表示目标的集合，就像一个数组，“$@”依次取出目标，并执于命令。&lt;/p&gt;
&lt;h5&gt;7、静态模式&lt;/h5&gt;
&lt;p&gt;静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;targets ...&amp;gt;: &amp;lt;target-pattern&amp;gt;: &amp;lt;prereq-patterns ...&amp;gt;

&amp;lt;commands&amp;gt;

...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。&lt;/p&gt;
&lt;p&gt;target-parrtern是指明了targets的模式，也就是的目标集模式。&lt;/p&gt;
&lt;p&gt;prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。&lt;/p&gt;
&lt;p&gt;这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的&lt;target-parrtern&gt;定义成“%.o”，意思是我们的&lt;target&gt;集合中都是以“.o”结尾的，而如果我们的&lt;prereq-parrterns&gt;定义成“%.c”，意思是对&lt;target-parrtern&gt;所形成的目标集进行二次定义，其计算方法是，取&lt;target-parrtern&gt;模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。&lt;/p&gt;
&lt;p&gt;所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“\”进行转义，来标明真实的“%”字符。&lt;/p&gt;
&lt;p&gt;看一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;objects&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; foo.o bar.o

&lt;span class="nf"&gt;all&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;objects&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;$(objects)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; %.&lt;span class="n"&gt;o&lt;/span&gt;: %.&lt;span class="n"&gt;c&lt;/span&gt;

&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;CC&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="err"&gt;-c&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;CFLAGS&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$&amp;lt;&lt;/span&gt; &lt;span class="err"&gt;-o&lt;/span&gt; &lt;span class="k"&gt;$@&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的例子中，指明了我们的目标从&lt;span class="math"&gt;\(object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量\)&lt;/span&gt;object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.c bar.c”。而命令中的“&lt;span class="math"&gt;\(&amp;lt;”和“\)&lt;/span&gt;@”则是自动化变量，“&lt;span class="math"&gt;\(&amp;lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“\)&lt;/span&gt;@”表示目标集（也就是“foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;foo.o &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;.&lt;span class="n"&gt;c&lt;/span&gt;

&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;CC&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="err"&gt;-c&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;CFLAGS&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="err"&gt;foo.c&lt;/span&gt; &lt;span class="err"&gt;-o&lt;/span&gt; &lt;span class="err"&gt;foo.o&lt;/span&gt;

&lt;span class="nf"&gt;bar.o &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;.&lt;span class="n"&gt;c&lt;/span&gt;

&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;CC&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="err"&gt;-c&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;CFLAGS&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="err"&gt;bar.c&lt;/span&gt; &lt;span class="err"&gt;-o&lt;/span&gt; &lt;span class="err"&gt;bar.o&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;files&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; foo.elc bar.o lose.o

&lt;span class="nf"&gt;$(filter %.o,$(files))&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; %.&lt;span class="n"&gt;o&lt;/span&gt;: %.&lt;span class="n"&gt;c&lt;/span&gt;

&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;CC&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="err"&gt;-c&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;CFLAGS&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$&amp;lt;&lt;/span&gt; &lt;span class="err"&gt;-o&lt;/span&gt; &lt;span class="k"&gt;$@&lt;/span&gt;

&lt;span class="nf"&gt;$(filter %.elc,$(files))&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; %.&lt;span class="n"&gt;elc&lt;/span&gt;: %.&lt;span class="n"&gt;el&lt;/span&gt;

&lt;span class="err"&gt;emacs&lt;/span&gt; &lt;span class="err"&gt;-f&lt;/span&gt; &lt;span class="err"&gt;batch-byte-compile&lt;/span&gt; &lt;span class="k"&gt;$&amp;lt;&lt;/span&gt;

&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;filter&lt;/span&gt; %.&lt;span class="nv"&gt;o&lt;/span&gt;,&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;files&lt;/span&gt;&lt;span class="k"&gt;))&lt;/span&gt;&lt;span class="err"&gt;表示调用Makefile的filter函数，过滤“$filter”集，只要其中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;8、自动生成依赖性&lt;/h5&gt;
&lt;p&gt;在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句“#include "defs.h"”，那么我们的依赖关系应该是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;main.o : main.c defs.h
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cc -M main.c
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其输出是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;main.o : main.c defs.h
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。&lt;/p&gt;
&lt;p&gt;gcc -M main.c的输出是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \

/usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \

/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \

/usr/include/bits/types.h /usr/include/bits/pthreadtypes.h \

/usr/include/bits/sched.h /usr/include/libio.h \

/usr/include/_G_config.h /usr/include/wchar.h \

/usr/include/bits/wchar.h /usr/include/gconv.h \

/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \

/usr/include/bits/stdio_lim.h
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;gcc -MM main.c的输出则是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;main.o: main.c defs.h
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile 自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。&lt;/p&gt;
&lt;p&gt;于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。&lt;/p&gt;
&lt;p&gt;这里，我们给出了一个模式规则来产生[.d]文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;%.d: %.c&lt;/span&gt;

&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;rm&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; $&lt;span class="p"&gt;@;&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;

$&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CC&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt; $&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CPPFLAGS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; $&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; $&lt;span class="p"&gt;@.&lt;/span&gt;$$$$&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;

&lt;span class="n"&gt;sed&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;s,\($*\)\.o[ :]*,\1.o $@ : ,g&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; $&lt;span class="p"&gt;@.&lt;/span&gt;$$$$ &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; $&lt;span class="p"&gt;@;&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;

&lt;span class="n"&gt;rm&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; $&lt;span class="p"&gt;@.&lt;/span&gt;$$$$
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm -f &lt;span class="math"&gt;\(@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“\)&lt;/span&gt;&amp;lt;”，也就是[.c]文件生成依赖文件，“&lt;span class="math"&gt;\(@”表示模式 “%.d”文件，如果有一个C文件是name.c，那么“%”就是“name”，“\)&lt;/span&gt;&lt;span class="math"&gt;\($\)&lt;/span&gt;”意为一个随机编号，第二行生成的文件有可能是 “name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。&lt;/p&gt;
&lt;p&gt;总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;main.o : main.c defs.h
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;转成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;main.o main.d : main.c defs.h
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个 [.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用 Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sources = foo.c bar.c

include $(sources:.c=.d)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述语句中的“&lt;span class="math"&gt;\((sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量\)&lt;/span&gt;(sources)所有[.c]的字串都替换成 [.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标。&lt;/p&gt;
&lt;h4&gt;十一、书写命令&lt;/h4&gt;
&lt;p&gt;每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。&lt;/p&gt;
&lt;p&gt;我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被“/bin/sh”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，“#”是注释符，很像C/C++中的“//”，其后的本行字符都被注释。&lt;/p&gt;
&lt;h5&gt;1、显示命令&lt;/h5&gt;
&lt;p&gt;通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：&lt;/p&gt;
&lt;p&gt;@echo 正在编译XXX模块......&lt;/p&gt;
&lt;p&gt;当make执行时，会输出“正在编译XXX模块......”字串，但不会输出命令，如果没有“@”，那么，make将输出：&lt;/p&gt;
&lt;p&gt;echo 正在编译XXX模块......&lt;/p&gt;
&lt;p&gt;正在编译XXX模块......&lt;/p&gt;
&lt;p&gt;如果make执行时，带入make参数“-n”或“--just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。&lt;/p&gt;
&lt;p&gt;而make参数“-s”或“--slient”则是全面禁止命令的显示。&lt;/p&gt;
&lt;h5&gt;2、命令执行&lt;/h5&gt;
&lt;p&gt;当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：&lt;/p&gt;
&lt;p&gt;示例一：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;

&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="sr"&gt;/home/&lt;/span&gt;&lt;span class="n"&gt;hchen&lt;/span&gt;

&lt;span class="n"&gt;pwd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;示例二：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;

&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="sr"&gt;/home/&lt;/span&gt;&lt;span class="n"&gt;hchen&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;pwd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当我们执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。&lt;/p&gt;
&lt;p&gt;make 一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS- DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。&lt;/p&gt;
&lt;h5&gt;3、命令出错&lt;/h5&gt;
&lt;p&gt;每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。&lt;/p&gt;
&lt;p&gt;有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。&lt;/p&gt;
&lt;p&gt;为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;clean:

-rm -f *.o
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还有一个全局的办法是，给make加上“-i”或是“--ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。&lt;/p&gt;
&lt;p&gt;还有一个要提一下的make的参数的是“-k”或是“--keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。&lt;/p&gt;
&lt;h5&gt;4、嵌套执行make&lt;/h5&gt;
&lt;p&gt;在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。&lt;/p&gt;
&lt;p&gt;例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;subsystem&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;

&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;subdir&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;$&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MAKE&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其等价于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;subsystem&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;

&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;MAKE&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="err"&gt;-C&lt;/span&gt; &lt;span class="err"&gt;subdir&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。&lt;/p&gt;
&lt;p&gt;我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。&lt;/p&gt;
&lt;p&gt;如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;export &amp;lt;variable ...&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;unexport &amp;lt;variable ...&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如：&lt;/p&gt;
&lt;p&gt;示例一：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;export variable = value
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其等价于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;variable = value

export variable
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其等价于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;export variable := value
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其等价于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;variable := value

export variable
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;示例二：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;export variable += value
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其等价于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;variable += value

export variable
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。&lt;/p&gt;
&lt;p&gt;需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。&lt;/p&gt;
&lt;p&gt;但是make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;subsystem&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;

&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;subdir&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;$&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MAKE&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;MAKEFLAGS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。&lt;/p&gt;
&lt;p&gt;还有一个在“嵌套执行”中比较有用的参数，“-w”或是“--print-directory”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;make&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Entering&lt;/span&gt; &lt;span class="n"&gt;directory&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/home/hchen/gnu/&lt;/span&gt;&lt;span class="n"&gt;make&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而在完成下层make后离开目录时，我们会看到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;make&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Leaving&lt;/span&gt; &lt;span class="n"&gt;directory&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/home/hchen/gnu/&lt;/span&gt;&lt;span class="n"&gt;make&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“--slient”）或是“--no-print-directory”，那么，“-w”总是失效的。&lt;/p&gt;
&lt;h5&gt;5、定义命令包&lt;/h5&gt;
&lt;p&gt;如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;define run-yacc

yacc $(firstword $^)

mv y.tab.c $@

endef
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;foo.c : foo.y

$(run-yacc)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的“&lt;span class="math"&gt;\(^”就是“foo.y”，“\)&lt;/span&gt;@”就是“foo.c”（有关这种以 “$”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。&lt;/p&gt;
&lt;h4&gt;十二、使用变量&lt;/h4&gt;
&lt;p&gt;在 Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是 Makefile的其它部分中。&lt;/p&gt;
&lt;p&gt;变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。&lt;/p&gt;
&lt;p&gt;有一些变量是很奇怪字串，如“&lt;span class="math"&gt;\(&amp;lt;”、“\)&lt;/span&gt;@”等，这些是自动化变量，我会在后面介绍。&lt;/p&gt;
&lt;h5&gt;1、变量的基础&lt;/h5&gt;
&lt;p&gt;变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“&lt;span class="math"&gt;\(”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来。如果你要使用真实的“\)&lt;/span&gt;”字符，那么你需要用“$$”来表示。&lt;/p&gt;
&lt;p&gt;变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;objects = program.o foo.o utils.o

program : $(objects)

cc -o program $(objects)

$(objects) : defs.h
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;foo = c

prog.o : prog.$(foo)

$(foo)$(foo) -$(foo) prog.$(foo)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;展开后得到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;prog.o : prog.c

cc -c prog.c
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。&lt;/p&gt;
&lt;p&gt;另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。&lt;/p&gt;
&lt;h5&gt;2、变量中的变量&lt;/h5&gt;
&lt;p&gt;在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。&lt;/p&gt;
&lt;p&gt;先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;foo = $(bar)

bar = $(ugh)

ugh = Huh?

all:

echo $(foo)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们执行“make all”将会打出变量&lt;span class="math"&gt;\((foo)的值是“Huh?”（ $(foo)的值是\)&lt;/span&gt;(bar)，&lt;span class="math"&gt;\((bar)的值是\)&lt;/span&gt;(ugh)，$(ugh)的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。&lt;/p&gt;
&lt;p&gt;这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面 
来定义，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CFLAGS = $(include_dirs) –O

include_dirs = -Ifoo –Ibar
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;CFLAGS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;CFLAGS&lt;span class="k"&gt;)&lt;/span&gt; –O
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;B&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;A&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。&lt;/p&gt;
&lt;p&gt;为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x := foo

y := $(x) bar

x := later
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其等价于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;y := foo bar

x := later
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;y := $(x) bar

x := foo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么，y的值是“bar”，而不是“foo bar”。&lt;/p&gt;
&lt;p&gt;上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量“MAKELEVEL”的使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ifeq (0,&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;MAKELEVEL&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;)

cur-dir := $(shell pwd)

whoami := $(shell whoami)

host-type := $(shell arch)

MAKE := &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;MAKE&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt; host-type=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt; whoami=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;whoami&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;

endif
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关于条件表达式和函数，我们在后面再说，对于系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的“嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。&lt;/p&gt;
&lt;p&gt;下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nullstring :=

space := $(nullstring) # end of the line
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;nullstring 是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个 Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dir := /foo/bar # directory to put the frobs in
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;dir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。&lt;/p&gt;
&lt;p&gt;还有一个比较有用的操作符是“?=”，先看示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FOO ?= bar
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ifeq ($(origin FOO), undefined)

FOO = bar

endif
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;3、变量高级用法&lt;/h5&gt;
&lt;p&gt;这里介绍两种变量的高级使用方法，第一种是变量值的替换。&lt;/p&gt;
&lt;p&gt;我们可以替换变量中的共有的部分，其格式是“&lt;span class="math" var:a="b"&gt;\((var:a=b)”或是“\)&lt;/span&gt;”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。&lt;/p&gt;
&lt;p&gt;还是看一个示例吧：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;foo := a.o b.o c.o

bar := $(foo:.o=.c)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个示例中，我们先定义了一个“&lt;span class="math"&gt;\((foo)”变量，而第二行的意思是把“\)&lt;/span&gt;(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。&lt;/p&gt;
&lt;p&gt;另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;foo := a.o b.o c.o

bar := $(foo:%.o=%.c)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c”。&lt;/p&gt;
&lt;p&gt;第二种高级用法是——“把变量的值再当成变量”。先看一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x = y

y = z

a := $($(x))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在这个例子中，&lt;span class="math"&gt;\((x)的值是“y”，所以\)&lt;/span&gt;(&lt;span class="math"&gt;\((x))就是\)&lt;/span&gt;(y)，于是&lt;span class="math"&gt;\((a)的值就是“z”。（注意，是“x=y”，而不是“x=\)&lt;/span&gt;(y)”）&lt;/p&gt;
&lt;p&gt;我们还可以使用更多的层次：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x = y

y = z

z = u

a := $($($(x)))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的$(a)的值是“u”，相关的推导留给读者自己去做吧。&lt;/p&gt;
&lt;p&gt;让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x = $(y)

y = z

z = Hello

a := $($(x))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的&lt;span class="math"&gt;\((\)&lt;/span&gt;(x))被替换成了&lt;span class="math"&gt;\((\)&lt;/span&gt;(y))，因为&lt;span class="math"&gt;\((y)值是“z”，所以，最终结果是：a:=\)&lt;/span&gt;(z)，也就是“Hello”。&lt;/p&gt;
&lt;p&gt;再复杂一点，我们再加上函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x = variable1

variable2 := Hello

y = $(subst 1,2,$(x))

z = y

a := $($($(z)))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个例子中，“&lt;span class="math"&gt;\((\)&lt;/span&gt;(&lt;span class="math"&gt;\((z)))”扩展为“\)&lt;/span&gt;(&lt;span class="math"&gt;\((y))”，而其再次被扩展为“\)&lt;/span&gt;(&lt;span class="math"&gt;\((subst 1,2,\)&lt;/span&gt;(x)))”。&lt;span class="math"&gt;\((x)的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成“variable2”，再取其值，所以，最终，\)&lt;/span&gt;(a)的值就是$(variable2)的值—— “Hello”。（喔，好不容易）&lt;/p&gt;
&lt;p&gt;在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;first_second = Hello

a = first

b = second

all = $($a_$b)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里的“&lt;span class="math"&gt;\(a_\)&lt;/span&gt;b”组成了“first_second”，于是，$(all)的值就是“Hello”。&lt;/p&gt;
&lt;p&gt;再来看看结合第一种技术的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a_objects := a.o b.o c.o

1_objects := 1.o 2.o 3.o

sources := $($(a1)_objects:.o=.c)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个例子中，如果&lt;span class="math"&gt;\((a1)的值是“a”的话，那么，\)&lt;/span&gt;(sources)的值就是“a.c b.c c.c”；如果&lt;span class="math"&gt;\((a1)的值是“1”，那么\)&lt;/span&gt;(sources)的值是“1.c 2.c 3.c”。&lt;/p&gt;
&lt;p&gt;再来看一个这种技术和“函数”与“条件语句”一同使用的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ifdef do_sort

func := sort

else

func := strip

endif

bar := a d b g q c

foo := $($(func) $(bar))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个示例中，如果定义了“do_sort”，那么：foo := &lt;span class="math"&gt;\((sort a d b g q c)，于是\)&lt;/span&gt;(foo)的值就是“a b c d g q”，而如果没有定义“do_sort”，那么：foo := $(sort a d b g q c)，调用的就是strip函数。&lt;/p&gt;
&lt;p&gt;当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dir = foo

$(dir)_sources := $(wildcard $(dir)/*.c)

define $(dir)_print

lpr $($(dir)_sources)

endef
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。&lt;/p&gt;
&lt;h5&gt;4、追加变量值&lt;/h5&gt;
&lt;p&gt;我们可以使用“+=”操作符给变量追加值，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;objects = main.o foo.o bar.o utils.o

objects += another.o
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;于是，我们的$(objects)值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）&lt;/p&gt;
&lt;p&gt;使用“+=”操作符，可以模拟为下面的这种例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;objects = main.o foo.o bar.o utils.o

objects := $(objects) another.o
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所不同的是，用“+=”更为简洁。&lt;/p&gt;
&lt;p&gt;如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;variable := value

variable += more
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;等价于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;variable := value

variable := $(variable) more
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但如果是这种情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;variable = value

variable += more
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。&lt;/p&gt;
&lt;h5&gt;5、override 指示符&lt;/h5&gt;
&lt;p&gt;如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;override &amp;lt;variable&amp;gt; = &amp;lt;value&amp;gt;

override &amp;lt;variable&amp;gt; := &amp;lt;value&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然，你还可以追加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;override &amp;lt;variable&amp;gt; += &amp;lt;more text&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用ovveride指示符，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;override define foo

bar

endef
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;6、多行变量&lt;/h5&gt;
&lt;p&gt;还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。&lt;/p&gt;
&lt;p&gt;define 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。&lt;/p&gt;
&lt;p&gt;下面的这个示例展示了define的用法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;define two-lines

echo foo

echo $(bar)

endef
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;7、环境变量&lt;/h5&gt;
&lt;p&gt;make 运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）&lt;/p&gt;
&lt;p&gt;因此，如果我们在环境变量中设置了“CFLAGS”环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。&lt;/p&gt;
&lt;p&gt;当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层 Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）&lt;/p&gt;
&lt;p&gt;当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。&lt;/p&gt;
&lt;h5&gt;8、目标变量&lt;/h5&gt;
&lt;p&gt;前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如“$&amp;lt;”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。&lt;/p&gt;
&lt;p&gt;当然，我样同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。&lt;/p&gt;
&lt;p&gt;其语法是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;target ...&amp;gt; : &amp;lt;variable-assignment&amp;gt;

&amp;lt;target ...&amp;gt; : overide &amp;lt;variable-assignment&amp;gt;

&amp;lt;variable-assignment&amp;gt;可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;prog&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CFLAGS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;

&lt;span class="n"&gt;prog&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;prog&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt;

&lt;span class="n"&gt;$&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CC&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;$&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CFLAGS&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;prog&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt;

&lt;span class="n"&gt;prog&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;prog&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt;

&lt;span class="n"&gt;$&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CC&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;$&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CFLAGS&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;prog&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt;

&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt;

&lt;span class="n"&gt;$&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CC&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;$&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CFLAGS&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt;

&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;o&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt;

&lt;span class="n"&gt;$&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CC&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;$&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CFLAGS&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在这个示例中，不管全局的&lt;span class="math"&gt;\((CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），\)&lt;/span&gt;(CFLAGS)的值都是“-g”。&lt;/p&gt;
&lt;h5&gt;9、模式变量&lt;/h5&gt;
&lt;p&gt;在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。&lt;/p&gt;
&lt;p&gt;我们知道，make的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;%.o : CFLAGS = -O&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同样，模式变量的语法和“目标变量”一样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;pattern ...&amp;gt; : &amp;lt;variable-assignment&amp;gt;

&amp;lt;pattern ...&amp;gt; : override &amp;lt;variable-assignment&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;override同样是针对于系统环境传入的变量，或是make命令行指定的变量。&lt;/p&gt;
&lt;h4&gt;十三、使用条件判断&lt;/h4&gt;
&lt;p&gt;使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以 
是比较变量的值，或是比较变量和常量的值。&lt;/p&gt;
&lt;h5&gt;1示例&lt;/h5&gt;
&lt;p&gt;下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用GNU函数编译目标。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;libs_for_gcc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; -lgnu

&lt;span class="nv"&gt;normal_libs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;

&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;objects&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="cp"&gt;ifeq ($(CC),gcc)&lt;/span&gt;

&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;CC&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="err"&gt;-o&lt;/span&gt; &lt;span class="err"&gt;foo&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;objects&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;libs_for_gcc&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="cp"&gt;else&lt;/span&gt;

&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;CC&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="err"&gt;-o&lt;/span&gt; &lt;span class="err"&gt;foo&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;objects&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;normal_libs&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="cp"&gt;endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可见，在上面示例的这个规则中，目标“foo”可以根据变量“$(CC)”值来选取不同的函数库来编译程序。&lt;/p&gt;
&lt;p&gt;我们可以从上面的示例中看到三个关键字：ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。&lt;/p&gt;
&lt;p&gt;当我们的变量$(CC)值是“gcc”时，目标foo的规则是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;objects&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;CC&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="err"&gt;-o&lt;/span&gt; &lt;span class="err"&gt;foo&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;objects&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;libs_for_gcc&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而当我们的变量$(CC)值不是“gcc”时（比如“cc”），目标foo的规则是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;objects&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;CC&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="err"&gt;-o&lt;/span&gt; &lt;span class="err"&gt;foo&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;objects&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;normal_libs&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然，我们还可以把上面的那个例子写得更简洁一些：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;libs_for_gcc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; -lgnu

&lt;span class="nv"&gt;normal_libs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;

&lt;span class="cp"&gt;ifeq ($(CC),gcc)&lt;/span&gt;

&lt;span class="nv"&gt;libs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;libs_for_gcc&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="cp"&gt;else&lt;/span&gt;

&lt;span class="nv"&gt;libs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;normal_libs&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="cp"&gt;endif&lt;/span&gt;

&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;objects&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;CC&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="err"&gt;-o&lt;/span&gt; &lt;span class="err"&gt;foo&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;objects&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;libs&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;2、语法&lt;/h5&gt;
&lt;p&gt;条件表达式的语法为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;conditional-directive&amp;gt;

&amp;lt;text-if-true&amp;gt;

endif
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以及：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;conditional-directive&amp;gt;

&amp;lt;text-if-true&amp;gt;

else

&amp;lt;text-if-false&amp;gt;

endif
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中&lt;conditional-directive&gt;表示条件关键字，如“ifeq”。这个关键字有四个。&lt;/p&gt;
&lt;p&gt;第一个是我们前面所见过的“ifeq”&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ifeq (&amp;lt;arg1&amp;gt;, &amp;lt;arg2&amp;gt; )

ifeq &amp;#39;&amp;lt;arg1&amp;gt;&amp;#39; &amp;#39;&amp;lt;arg2&amp;gt;&amp;#39;

ifeq &amp;quot;&amp;lt;arg1&amp;gt;&amp;quot; &amp;quot;&amp;lt;arg2&amp;gt;&amp;quot;

ifeq &amp;quot;&amp;lt;arg1&amp;gt;&amp;quot; &amp;#39;&amp;lt;arg2&amp;gt;&amp;#39;

ifeq &amp;#39;&amp;lt;arg1&amp;gt;&amp;#39; &amp;quot;&amp;lt;arg2&amp;gt;&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ifeq ($(strip $(foo)),)

&amp;lt;text-if-empty&amp;gt;

endif
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个示例中使用了“strip”函数，如果这个函数的返回值是空（Empty），那么&lt;text-if-empty&gt;就生效。&lt;/p&gt;
&lt;p&gt;第二个条件关键字是“ifneq”。语法是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ifneq (&amp;lt;arg1&amp;gt;, &amp;lt;arg2&amp;gt; )

ifneq &amp;#39;&amp;lt;arg1&amp;gt;&amp;#39; &amp;#39;&amp;lt;arg2&amp;gt;&amp;#39;

ifneq &amp;quot;&amp;lt;arg1&amp;gt;&amp;quot; &amp;quot;&amp;lt;arg2&amp;gt;&amp;quot;

ifneq &amp;quot;&amp;lt;arg1&amp;gt;&amp;quot; &amp;#39;&amp;lt;arg2&amp;gt;&amp;#39;

ifneq &amp;#39;&amp;lt;arg1&amp;gt;&amp;#39; &amp;quot;&amp;lt;arg2&amp;gt;&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其比较参数“arg1”和“arg2”的值是否相同，如果不同，则为真。和“ifeq”类似。&lt;/p&gt;
&lt;p&gt;第三个条件关键字是“ifdef”。语法是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ifdef &amp;lt;variable-name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果变量&lt;variable-name&gt;的值非空，那到表达式为真。否则，表达式为假。当然，&lt;variable-name&gt;同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：&lt;/p&gt;
&lt;p&gt;示例一：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bar =

foo = $(bar)

ifdef foo

frobozz = yes

else

frobozz = no

endif
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;示例二：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;foo =

ifdef foo

frobozz = yes

else

frobozz = no

endif
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第一个例子中，“$(frobozz)”值是“yes”，第二个则是“no”。&lt;/p&gt;
&lt;p&gt;第四个条件关键字是“ifndef”。其语法是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ifndef &amp;lt;variable-name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个我就不多说了，和“ifdef”是相反的意思。&lt;/p&gt;
&lt;p&gt;在&lt;conditional-directive&gt;这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也一样，只要不是以[Tab]键开始就行了。&lt;/p&gt;
&lt;p&gt;特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。&lt;/p&gt;
&lt;p&gt;而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。&lt;/p&gt;
&lt;h4&gt;十四、使用函数&lt;/h4&gt;
&lt;p&gt;在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。&lt;/p&gt;
&lt;h5&gt;1、函数的调用语法&lt;/h5&gt;
&lt;p&gt;函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(&amp;lt;function&amp;gt; &amp;lt;arguments&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里，&lt;function&gt;就是函数名，make支持的函数不多。&lt;arguments&gt;是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。函数调用以“&lt;span class="math"&gt;\(”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用“\)&lt;/span&gt;(subst a,b,&lt;span class="math"&gt;\((x))”这样的形式，而不是“\)&lt;/span&gt;(subst a,b,${x})”的形式。因为统一会更清楚，也会减少一些不必要的麻烦。&lt;/p&gt;
&lt;p&gt;还是来看一个示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;comma:= ,

empty:=

space:= $(empty) $(empty)

foo:= a b c

bar:= $(subst $(space),$(comma),$(foo))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在这个示例中，&lt;span class="math"&gt;\((comma)的值是一个逗号。\)&lt;/span&gt;(space)使用了&lt;span class="math"&gt;\((empty)定义了一个空格，\)&lt;/span&gt;(foo)的值是“a b c”，&lt;span class="math"&gt;\((bar)的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把\)&lt;/span&gt;(foo)中的空格替换成逗号，所以$(bar)的值是“a,b,c”。&lt;/p&gt;
&lt;h5&gt;2、字符串处理函数&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(subst &amp;lt;from&amp;gt;,&amp;lt;to&amp;gt;,&amp;lt;text&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：字符串替换函数——subst。&lt;/p&gt;
&lt;p&gt;功能：把字串&lt;text&gt;中的&lt;from&gt;字符串替换成&lt;to&gt;。&lt;/p&gt;
&lt;p&gt;返回：函数返回被替换过后的字符串。&lt;/p&gt;
&lt;p&gt;示例：$(subst ee,EE,feet on the street)，把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(patsubst &amp;lt;pattern&amp;gt;,&amp;lt;replacement&amp;gt;,&amp;lt;text&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：模式字符串替换函数——patsubst。&lt;/p&gt;
&lt;p&gt;功能：查找&lt;text&gt;中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式&lt;pattern&gt;，如果匹配的话，则以&lt;replacement&gt;替换。这里，&lt;pattern&gt;可以包括通配符“%”，表示任意长度的字串。如果&lt;replacement&gt;中也包含“%”，那么，&lt;replacement&gt;中的这个“%”将是&lt;pattern&gt;中的那个“%”所代表的字串。（可以用“\”来转义，以“\%”来表示真实含义的“%”字符）&lt;/p&gt;
&lt;p&gt;返回：函数返回被替换过后的字符串。&lt;/p&gt;
&lt;p&gt;示例：$(patsubst %.c,%.o,x.c.c bar.c)把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o”&lt;/p&gt;
&lt;p&gt;备注：这和我们前面“变量章节”说过的相关知识有点相似。如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;“$(var:&amp;lt;pattern&amp;gt;=&amp;lt;replacement&amp;gt; )”相当于“$(patsubst &amp;lt;pattern&amp;gt;,&amp;lt;replacement&amp;gt;,$(var))”，而“$(var: &amp;lt;suffix&amp;gt;=&amp;lt;replacement&amp;gt; )”则相当于“$(patsubst %&amp;lt;suffix&amp;gt;,%&amp;lt;replacement&amp;gt;,$(var))”。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;例如有：objects = foo.o bar.o baz.o，那么，“&lt;span class="math"&gt;\((objects:.o=.c)”和“\)&lt;/span&gt;(patsubst %.o,%.c,$(objects))”是一样的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(strip &amp;lt;string&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：去空格函数——strip。&lt;/p&gt;
&lt;p&gt;功能：去掉&lt;string&gt;字串中开头和结尾的空字符。&lt;/p&gt;
&lt;p&gt;返回：返回被去掉空格的字符串值。&lt;/p&gt;
&lt;p&gt;示例：$(strip a b c )把字串“a b c ”去到开头和结尾的空格，结果是“a b c”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(findstring &amp;lt;find&amp;gt;,&amp;lt;in&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：查找字符串函数——findstring。&lt;/p&gt;
&lt;p&gt;功能：在字串&lt;in&gt;中查找&lt;find&gt;字串。&lt;/p&gt;
&lt;p&gt;返回：如果找到，那么返回&lt;find&gt;，否则返回空字符串。&lt;/p&gt;
&lt;p&gt;示例：&lt;span class="math"&gt;\((findstring a,a b c)返回“a”字符串，\)&lt;/span&gt;(findstring a,b c)返回“”字符串（空字符串）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(filter &amp;lt;pattern...&amp;gt;,&amp;lt;text&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：过滤函数——filter。&lt;/p&gt;
&lt;p&gt;功能：以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词，保留符合模式&lt;pattern&gt;的单词。可以有多个模式。&lt;/p&gt;
&lt;p&gt;返回：返回符合模式&lt;pattern&gt;的字串。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sources := foo.c bar.c baz.s ugh.h

foo: $(sources)

cc $(filter %.c %.s,$(sources)) -o foo

$(filter %.c %.s,$(sources))返回的值是“foo.c bar.c baz.s”。

$(filter-out &amp;lt;pattern...&amp;gt;,&amp;lt;text&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：反过滤函数——filter-out。&lt;/p&gt;
&lt;p&gt;功能：以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词，去除符合模式&lt;pattern&gt;的单词。可以有多个模式。&lt;/p&gt;
&lt;p&gt;返回：返回不符合模式&lt;pattern&gt;的字串。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;objects=main1.o foo.o main2.o bar.o

mains=main1.o main2.o

$(filter-out $(mains),$(objects)) 返回值是“foo.o bar.o”。

$(sort &amp;lt;list&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：排序函数——sort。&lt;/p&gt;
&lt;p&gt;功能：给字符串&lt;list&gt;中的单词排序（升序）。&lt;/p&gt;
&lt;p&gt;返回：返回排序后的字符串。&lt;/p&gt;
&lt;p&gt;示例：$(sort foo bar lose)返回“bar foo lose” 。&lt;/p&gt;
&lt;p&gt;备注：sort函数会去掉&lt;list&gt;中相同的单词。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(word &amp;lt;n&amp;gt;,&amp;lt;text&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：取单词函数——word。&lt;/p&gt;
&lt;p&gt;功能：取字符串&lt;text&gt;中第&lt;n&gt;个单词。（从一开始）&lt;/p&gt;
&lt;p&gt;返回：返回字符串&lt;text&gt;中第&lt;n&gt;个单词。如果&lt;n&gt;比&lt;text&gt;中的单词数要大，那么返回空字符串。&lt;/p&gt;
&lt;p&gt;示例：$(word 2, foo bar baz)返回值是“bar”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(wordlist &amp;lt;s&amp;gt;,&amp;lt;e&amp;gt;,&amp;lt;text&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：取单词串函数——wordlist。&lt;/p&gt;
&lt;p&gt;功能：从字符串&lt;text&gt;中取从&lt;s&gt;开始到&lt;e&gt;的单词串。&lt;s&gt;和&lt;e&gt;是一个数字。&lt;/p&gt;
&lt;p&gt;返回：返回字符串&lt;text&gt;中从&lt;s&gt;到&lt;e&gt;的单词字串。如果&lt;s&gt;比&lt;text&gt;中的单词数要大，那么返回空字符串。如果&lt;e&gt;大于&lt;text&gt;的单词数，那么返回从&lt;s&gt;开始，到&lt;text&gt;结束的单词串。&lt;/p&gt;
&lt;p&gt;示例： $(wordlist 2, 3, foo bar baz)返回值是“bar baz”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(words &amp;lt;text&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：单词个数统计函数——words。&lt;/p&gt;
&lt;p&gt;功能：统计&lt;text&gt;中字符串中的单词个数。&lt;/p&gt;
&lt;p&gt;返回：返回&lt;text&gt;中的单词数。&lt;/p&gt;
&lt;p&gt;示例：$(words, foo bar baz)返回值是“3”。&lt;/p&gt;
&lt;p&gt;备注：如果我们要取&lt;text&gt;中最后的一个单词，我们可以这样：$(word $(words &lt;text&gt; ),&lt;text&gt; )。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(firstword &amp;lt;text&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：首单词函数——firstword。&lt;/p&gt;
&lt;p&gt;功能：取字符串&lt;text&gt;中的第一个单词。&lt;/p&gt;
&lt;p&gt;返回：返回字符串&lt;text&gt;的第一个单词。&lt;/p&gt;
&lt;p&gt;示例：$(firstword foo bar)返回值是“foo”。&lt;/p&gt;
&lt;p&gt;备注：这个函数可以用word函数来实现：$(word 1,&lt;text&gt; )。&lt;/p&gt;
&lt;p&gt;以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;override CFLAGS += $(patsubst %,-I%,$(subst &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;VPATH&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果我们的“&lt;span class="math"&gt;\((VPATH)”值是“src:../headers”，那么“\)&lt;/span&gt;(patsubst %,-I%,&lt;span class="math"&gt;\((subst :, ,\)&lt;/span&gt;(VPATH)))”将返回“-Isrc -I../headers”，这正是cc或gcc搜索头文件路径的参数。&lt;/p&gt;
&lt;h5&gt;3、文件名操作函数&lt;/h5&gt;
&lt;p&gt;下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(dir &amp;lt;names...&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：取目录函数——dir。&lt;/p&gt;
&lt;p&gt;功能：从文件名序列&lt;names&gt;中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。&lt;/p&gt;
&lt;p&gt;返回：返回文件名序列&lt;names&gt;的目录部分。&lt;/p&gt;
&lt;p&gt;示例： $(dir src/foo.c hacks)返回值是“src/ ./”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(notdir &amp;lt;names...&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：取文件函数——notdir。&lt;/p&gt;
&lt;p&gt;功能：从文件名序列&lt;names&gt;中取出非目录部分。非目录部分是指最后一个反斜杠（“/”）之后的部分。&lt;/p&gt;
&lt;p&gt;返回：返回文件名序列&lt;names&gt;的非目录部分。&lt;/p&gt;
&lt;p&gt;示例： $(notdir src/foo.c hacks)返回值是“foo.c hacks”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(suffix &amp;lt;names...&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：取后缀函数——suffix。&lt;/p&gt;
&lt;p&gt;功能：从文件名序列&lt;names&gt;中取出各个文件名的后缀。&lt;/p&gt;
&lt;p&gt;返回：返回文件名序列&lt;names&gt;的后缀序列，如果文件没有后缀，则返回空字串。&lt;/p&gt;
&lt;p&gt;示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(basename &amp;lt;names...&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：取前缀函数——basename。&lt;/p&gt;
&lt;p&gt;功能：从文件名序列&lt;names&gt;中取出各个文件名的前缀部分。&lt;/p&gt;
&lt;p&gt;返回：返回文件名序列&lt;names&gt;的前缀序列，如果文件没有前缀，则返回空字串。&lt;/p&gt;
&lt;p&gt;示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo src-1.0/bar hacks”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(addsuffix &amp;lt;suffix&amp;gt;,&amp;lt;names...&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：加后缀函数——addsuffix。&lt;/p&gt;
&lt;p&gt;功能：把后缀&lt;suffix&gt;加到&lt;names&gt;中的每个单词后面。&lt;/p&gt;
&lt;p&gt;返回：返回加过后缀的文件名序列。&lt;/p&gt;
&lt;p&gt;示例：$(addsuffix .c,foo bar)返回值是“foo.c bar.c”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(addprefix &amp;lt;prefix&amp;gt;,&amp;lt;names...&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：加前缀函数——addprefix。&lt;/p&gt;
&lt;p&gt;功能：把前缀&lt;prefix&gt;加到&lt;names&gt;中的每个单词后面。&lt;/p&gt;
&lt;p&gt;返回：返回加过前缀的文件名序列。&lt;/p&gt;
&lt;p&gt;示例：$(addprefix src/,foo bar)返回值是“src/foo src/bar”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(join &amp;lt;list1&amp;gt;,&amp;lt;list2&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;名称：连接函数——join。&lt;/p&gt;
&lt;p&gt;功能：把&lt;list2&gt;中的单词对应地加到&lt;list1&gt;的单词后面。如果&lt;list1&gt;的单词个数要比&lt;list2&gt;的多，那么，&lt;list1&gt;中的多出来的单词将保持原样。如果&lt;list2&gt;的单词个数要比&lt;list1&gt;多，那么，&lt;list2&gt;多出来的单词将被复制到&lt;list2&gt;中。&lt;/p&gt;
&lt;p&gt;返回：返回连接过后的字符串。&lt;/p&gt;
&lt;p&gt;示例：$(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”。&lt;/p&gt;
&lt;h5&gt;4、foreach 函数&lt;/h5&gt;
&lt;p&gt;foreach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的foreach函数几乎是仿照于Unix标准Shell（/bin /sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(foreach &amp;lt;var&amp;gt;,&amp;lt;list&amp;gt;,&amp;lt;text&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个函数的意思是，把参数&lt;list&gt;中的单词逐一取出放到参数&lt;var&gt;所指定的变量中，然后再执行&lt;text&gt;所包含的表达式。每一次&lt;text&gt;会返回一个字符串，循环过程中，&lt;text&gt;的所返回的每个字符串会以空格分隔，最后当整个循环结束时，&lt;text&gt;所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。&lt;/p&gt;
&lt;p&gt;所以，&lt;var&gt;最好是一个变量名，&lt;list&gt;可以是一个表达式，而&lt;text&gt;中一般会使用&lt;var&gt;这个参数来依次枚举&lt;list&gt;中的单词。举个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;names := a b c d

files := $(foreach n,$(names),$(n).o)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的例子中，&lt;span class="math"&gt;\((name)中的单词会被挨个取出，并存到变量“n”中，“\)&lt;/span&gt;(n).o”每次根据“&lt;span class="math"&gt;\((n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，\)&lt;/span&gt;(files)的值是“a.o b.o c.o d.o”。&lt;/p&gt;
&lt;p&gt;注意，foreach中的&lt;var&gt;参数是一个临时的局部变量，foreach函数执行完后，参数&lt;var&gt;的变量将不在作用，其作用域只在foreach函数当中。&lt;/p&gt;
&lt;h5&gt;5、if 函数&lt;/h5&gt;
&lt;p&gt;if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(if &amp;lt;condition&amp;gt;,&amp;lt;then-part&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(if &amp;lt;condition&amp;gt;,&amp;lt;then-part&amp;gt;,&amp;lt;else-part&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。&lt;condition&gt;参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，&lt;then-part&gt;会被计算，否则&lt;else-part&gt; 会被计算。&lt;/p&gt;
&lt;p&gt;而if函数的返回值是，如果&lt;condition&gt;为真（非空字符串），那个&lt;then- part&gt;会是整个函数的返回值，如果&lt;condition&gt;为假（空字符串），那么&lt;else-part&gt;会是整个函数的返回值，此时如果&lt;else-part&gt;没有被定义，那么，整个函数返回空字串。&lt;/p&gt;
&lt;p&gt;所以，&lt;then-part&gt;和&lt;else-part&gt;只会有一个被计算。&lt;/p&gt;
&lt;h5&gt;6、call函数&lt;/h5&gt;
&lt;p&gt;call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(call &amp;lt;expression&amp;gt;,&amp;lt;parm1&amp;gt;,&amp;lt;parm2&amp;gt;,&amp;lt;parm3&amp;gt;...)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当 make执行这个函数时，&lt;expression&gt;参数中的变量，如&lt;span class="math"&gt;\((1)，\)&lt;/span&gt;(2)，$(3)等，会被参数&lt;parm1&gt;，&lt;parm2&gt;，&lt;parm3&gt;依次取代。而&lt;expression&gt;的返回值就是 call函数的返回值。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;reverse = $(1) $(2)

foo = $(call reverse,a,b)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么，foo的值就是“a b”。当然，参数的次序是可以自定义的，不一定是顺序的，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;reverse = $(2) $(1)

foo = $(call reverse,a,b)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时的foo的值就是“b a”。&lt;/p&gt;
&lt;h5&gt;7、origin函数&lt;/h5&gt;
&lt;p&gt;origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(origin &amp;lt;variable&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意，&lt;variable&gt;是变量的名字，不应该是引用。所以你最好不要在&lt;variable&gt;中使用“$”字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;“undefined”
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果&lt;variable&gt;从来没有定义过，origin函数返回这个值“undefined”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;“default”
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果&lt;variable&gt;是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;“environment”
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果&lt;variable&gt;是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;“file”
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果&lt;variable&gt;这个变量被定义在Makefile中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;“command line”
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果&lt;variable&gt;这个变量是被命令行定义的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;“override”
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果&lt;variable&gt;是被override指示符重新定义的。&lt;/p&gt;
&lt;p&gt;“automatic”&lt;/p&gt;
&lt;p&gt;如果&lt;variable&gt;是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。&lt;/p&gt;
&lt;p&gt;这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ifdef bletch

ifeq &amp;quot;$(origin bletch)&amp;quot; &amp;quot;environment&amp;quot;

bletch = barf, gag, etc.

endif

endif
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。&lt;/p&gt;
&lt;h5&gt;8、shell函数&lt;/h5&gt;
&lt;p&gt;shell 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;contents := $(shell cat foo)

files := $(shell echo *.c)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。&lt;/p&gt;
&lt;h5&gt;9、控制make的函数&lt;/h5&gt;
&lt;p&gt;make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(error &amp;lt;text ...&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;产生一个致命的错误，&lt;text ...&gt;是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：&lt;/p&gt;
&lt;p&gt;示例一：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ifdef ERROR_001

$(error error is $(ERROR_001))

endif
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;示例二：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;ERR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;error found an error!&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;.PHONY&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;err&lt;/span&gt;

&lt;span class="nf"&gt;err&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; ; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;ERR&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$(warning &amp;lt;text ...&amp;gt; )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。&lt;/p&gt;
&lt;h4&gt;十五、make的运行&lt;/h4&gt;
&lt;p&gt;一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让 make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。&lt;/p&gt;
&lt;h5&gt;1、make的退出码&lt;/h5&gt;
&lt;p&gt;make命令执行后有三个退出码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;0 —— 表示成功执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1 —— 如果make运行时出现任何错误，其返回1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Make的相关参数我们会在后续章节中讲述。&lt;/p&gt;
&lt;h5&gt;2、指定Makefile&lt;/h5&gt;
&lt;p&gt;前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。&lt;/p&gt;
&lt;p&gt;当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的“-f”或是“--file”参数（“-- makefile”参数也行）。例如，我们有个makefile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;make –f hchen.mk
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果在make的命令行是，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。&lt;/p&gt;
&lt;h5&gt;3、指定目标&lt;/h5&gt;
&lt;p&gt;一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的 makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）&lt;/p&gt;
&lt;p&gt;任何在makefile中的目标都可以被指定成终极目标，但是除了以“- ”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。&lt;/p&gt;
&lt;p&gt;有一个make的环境变量叫“MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;sources&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; foo.c bar.c

&lt;span class="cp"&gt;ifneq ( $(MAKECMDGOALS),clean)&lt;/span&gt;

&lt;span class="cp"&gt;include $(sources:.c=.d)&lt;/span&gt;

&lt;span class="cp"&gt;endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;基于上面的这个例子，只要我们输入的命令不是“make clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。&lt;/p&gt;
&lt;p&gt;使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;.PHONY:&lt;/span&gt; &lt;span class="nf"&gt;all&lt;/span&gt;

&lt;span class="nl"&gt;all:&lt;/span&gt; &lt;span class="nf"&gt;prog1&lt;/span&gt; &lt;span class="no"&gt;prog2&lt;/span&gt; &lt;span class="no"&gt;prog3&lt;/span&gt; &lt;span class="no"&gt;prog4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——“prog1”，“prog2”，“prog3”和“prog4”，我们可以使用“make all”命令来编译所有的目标（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用“make prog2”来单独编译目标“prog2”。&lt;/p&gt;
&lt;p&gt;即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其 makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。&lt;/p&gt;
&lt;p&gt;“all”&lt;/p&gt;
&lt;p&gt;这个伪目标是所有目标的目标，其功能一般是编译所有的目标。&lt;/p&gt;
&lt;p&gt;“clean”&lt;/p&gt;
&lt;p&gt;这个伪目标功能是删除所有被make创建的文件。&lt;/p&gt;
&lt;p&gt;“install”&lt;/p&gt;
&lt;p&gt;这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。&lt;/p&gt;
&lt;p&gt;“print”&lt;/p&gt;
&lt;p&gt;这个伪目标的功能是例出改变过的源文件。&lt;/p&gt;
&lt;p&gt;“tar”&lt;/p&gt;
&lt;p&gt;这个伪目标功能是把源程序打包备份。也就是一个tar文件。&lt;/p&gt;
&lt;p&gt;“dist”&lt;/p&gt;
&lt;p&gt;这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。&lt;/p&gt;
&lt;p&gt;“TAGS”&lt;/p&gt;
&lt;p&gt;这个伪目标功能是更新所有的目标，以备完整地重编译使用。&lt;/p&gt;
&lt;p&gt;“check”和“test”&lt;/p&gt;
&lt;p&gt;这两个伪目标一般用来测试makefile的流程。&lt;/p&gt;
&lt;p&gt;当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。&lt;/p&gt;
&lt;h5&gt;4、检查规则&lt;/h5&gt;
&lt;p&gt;有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：&lt;/p&gt;
&lt;p&gt;“-n”&lt;/p&gt;
&lt;p&gt;“--just-print”&lt;/p&gt;
&lt;p&gt;“--dry-run”&lt;/p&gt;
&lt;p&gt;“--recon”&lt;/p&gt;
&lt;p&gt;不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。&lt;/p&gt;
&lt;p&gt;“-t”&lt;/p&gt;
&lt;p&gt;“--touch”&lt;/p&gt;
&lt;p&gt;这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。&lt;/p&gt;
&lt;p&gt;“-q”&lt;/p&gt;
&lt;p&gt;“--question”&lt;/p&gt;
&lt;p&gt;这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。&lt;/p&gt;
&lt;p&gt;“-W &lt;file&gt;”&lt;/p&gt;
&lt;p&gt;“--what-if=&lt;file&gt;”&lt;/p&gt;
&lt;p&gt;“--assume-new=&lt;file&gt;”&lt;/p&gt;
&lt;p&gt;“--new-file=&lt;file&gt;”&lt;/p&gt;
&lt;p&gt;这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。&lt;/p&gt;
&lt;p&gt;另外一个很有意思的用法是结合“-p”和“-v”来输出makefile被执行时的信息（这个将在后面讲述）。&lt;/p&gt;
&lt;h5&gt;5、make的参数&lt;/h5&gt;
&lt;p&gt;下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。&lt;/p&gt;
&lt;p&gt;“-b”&lt;/p&gt;
&lt;p&gt;“-m”&lt;/p&gt;
&lt;p&gt;这两个参数的作用是忽略和其它版本make的兼容性。&lt;/p&gt;
&lt;p&gt;“-B”&lt;/p&gt;
&lt;p&gt;“--always-make”&lt;/p&gt;
&lt;p&gt;认为所有的目标都需要更新（重编译）。&lt;/p&gt;
&lt;p&gt;“-C &lt;dir&gt;”&lt;/p&gt;
&lt;p&gt;“--directory=&lt;dir&gt;”&lt;/p&gt;
&lt;p&gt;指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”等价于“make –C ~hchen/test/prog”。&lt;/p&gt;
&lt;p&gt;“—debug[=&lt;options&gt;]”&lt;/p&gt;
&lt;p&gt;输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是&lt;options&gt;的取值：&lt;/p&gt;
&lt;p&gt;a —— 也就是all，输出所有的调试信息。（会非常的多）&lt;/p&gt;
&lt;p&gt;b —— 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。&lt;/p&gt;
&lt;p&gt;v —— 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。&lt;/p&gt;
&lt;p&gt;i —— 也就是implicit，输出所以的隐含规则。&lt;/p&gt;
&lt;p&gt;j —— 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。&lt;/p&gt;
&lt;p&gt;m —— 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。&lt;/p&gt;
&lt;p&gt;“-d”&lt;/p&gt;
&lt;p&gt;相当于“--debug=a”。&lt;/p&gt;
&lt;p&gt;“-e”&lt;/p&gt;
&lt;p&gt;“--environment-overrides”&lt;/p&gt;
&lt;p&gt;指明环境变量的值覆盖makefile中定义的变量的值。&lt;/p&gt;
&lt;p&gt;“-f=&lt;file&gt;”&lt;/p&gt;
&lt;p&gt;“--file=&lt;file&gt;”&lt;/p&gt;
&lt;p&gt;“--makefile=&lt;file&gt;”&lt;/p&gt;
&lt;p&gt;指定需要执行的makefile。&lt;/p&gt;
&lt;p&gt;“-h”&lt;/p&gt;
&lt;p&gt;“--help”&lt;/p&gt;
&lt;p&gt;显示帮助信息。&lt;/p&gt;
&lt;p&gt;“-i”&lt;/p&gt;
&lt;p&gt;“--ignore-errors”&lt;/p&gt;
&lt;p&gt;在执行时忽略所有的错误。&lt;/p&gt;
&lt;p&gt;“-I &lt;dir&gt;”&lt;/p&gt;
&lt;p&gt;“--include-dir=&lt;dir&gt;”&lt;/p&gt;
&lt;p&gt;指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。&lt;/p&gt;
&lt;p&gt;“-j [&lt;jobsnum&gt;]”&lt;/p&gt;
&lt;p&gt;“--jobs[=&lt;jobsnum&gt;]”&lt;/p&gt;
&lt;p&gt;指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-DOS中是无用的）&lt;/p&gt;
&lt;p&gt;“-k”&lt;/p&gt;
&lt;p&gt;“--keep-going”&lt;/p&gt;
&lt;p&gt;出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。&lt;/p&gt;
&lt;p&gt;“-l &lt;load&gt;”&lt;/p&gt;
&lt;p&gt;“--load-average[=&amp;lt;load]”&lt;/p&gt;
&lt;p&gt;“—max-load[=&lt;load&gt;]”&lt;/p&gt;
&lt;p&gt;指定make运行命令的负载。&lt;/p&gt;
&lt;p&gt;“-n”&lt;/p&gt;
&lt;p&gt;“--just-print”&lt;/p&gt;
&lt;p&gt;“--dry-run”&lt;/p&gt;
&lt;p&gt;“--recon”&lt;/p&gt;
&lt;p&gt;仅输出执行过程中的命令序列，但并不执行。&lt;/p&gt;
&lt;p&gt;“-o &lt;file&gt;”&lt;/p&gt;
&lt;p&gt;“--old-file=&lt;file&gt;”&lt;/p&gt;
&lt;p&gt;“--assume-old=&lt;file&gt;”&lt;/p&gt;
&lt;p&gt;不重新生成的指定的&lt;file&gt;，即使这个目标的依赖文件新于它。&lt;/p&gt;
&lt;p&gt;“-p”&lt;/p&gt;
&lt;p&gt;“--print-data-base”&lt;/p&gt;
&lt;p&gt;输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行 makefile，你可以使用“make -qp”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。&lt;/p&gt;
&lt;p&gt;“-q”&lt;/p&gt;
&lt;p&gt;“--question”&lt;/p&gt;
&lt;p&gt;不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。&lt;/p&gt;
&lt;p&gt;“-r”&lt;/p&gt;
&lt;p&gt;“--no-builtin-rules”&lt;/p&gt;
&lt;p&gt;禁止make使用任何隐含规则。&lt;/p&gt;
&lt;p&gt;“-R”&lt;/p&gt;
&lt;p&gt;“--no-builtin-variabes”&lt;/p&gt;
&lt;p&gt;禁止make使用任何作用于变量上的隐含规则。&lt;/p&gt;
&lt;p&gt;“-s”&lt;/p&gt;
&lt;p&gt;“--silent”&lt;/p&gt;
&lt;p&gt;“--quiet”&lt;/p&gt;
&lt;p&gt;在命令运行时不输出命令的输出。&lt;/p&gt;
&lt;p&gt;“-S”&lt;/p&gt;
&lt;p&gt;“--no-keep-going”&lt;/p&gt;
&lt;p&gt;“--stop”&lt;/p&gt;
&lt;p&gt;取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。&lt;/p&gt;
&lt;p&gt;“-t”&lt;/p&gt;
&lt;p&gt;“--touch”&lt;/p&gt;
&lt;p&gt;相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。&lt;/p&gt;
&lt;p&gt;“-v”&lt;/p&gt;
&lt;p&gt;“--version”&lt;/p&gt;
&lt;p&gt;输出make程序的版本、版权等关于make的信息。&lt;/p&gt;
&lt;p&gt;“-w”&lt;/p&gt;
&lt;p&gt;“--print-directory”&lt;/p&gt;
&lt;p&gt;输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。&lt;/p&gt;
&lt;p&gt;“--no-print-directory”&lt;/p&gt;
&lt;p&gt;禁止“-w”选项。&lt;/p&gt;
&lt;p&gt;“-W &lt;file&gt;”&lt;/p&gt;
&lt;p&gt;“--what-if=&lt;file&gt;”&lt;/p&gt;
&lt;p&gt;“--new-file=&lt;file&gt;”&lt;/p&gt;
&lt;p&gt;“--assume-file=&lt;file&gt;”&lt;/p&gt;
&lt;p&gt;假定目标&lt;file&gt;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得&lt;file&gt;的修改时间为当前时间。&lt;/p&gt;
&lt;p&gt;“--warn-undefined-variables”&lt;/p&gt;
&lt;p&gt;只要make发现有未定义的变量，那么就输出警告信息。&lt;/p&gt;
&lt;h4&gt;十六、隐含规则&lt;/h4&gt;
&lt;p&gt;在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o] 文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。&lt;/p&gt;
&lt;p&gt;“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。&lt;/p&gt;
&lt;p&gt;“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。&lt;/p&gt;
&lt;p&gt;我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保证我们Makefile的兼容性。我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。&lt;/p&gt;
&lt;h5&gt;1、使用隐含规则&lt;/h5&gt;
&lt;p&gt;如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：&lt;/p&gt;
&lt;p&gt;foo : foo.o bar.o&lt;/p&gt;
&lt;p&gt;cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)&lt;/p&gt;
&lt;p&gt;我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。&lt;/p&gt;
&lt;p&gt;make 会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把 [.o]的目标的依赖文件置成[.c]，并使用C的编译命令“cc –c $(CFLAGS) [.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：&lt;/p&gt;
&lt;p&gt;foo.o : foo.c&lt;/p&gt;
&lt;p&gt;cc –c foo.c $(CFLAGS)&lt;/p&gt;
&lt;p&gt;bar.o : bar.c&lt;/p&gt;
&lt;p&gt;cc –c bar.c $(CFLAGS)&lt;/p&gt;
&lt;p&gt;因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。&lt;/p&gt;
&lt;p&gt;当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。&lt;/p&gt;
&lt;p&gt;还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：&lt;/p&gt;
&lt;p&gt;foo.o : foo.p&lt;/p&gt;
&lt;p&gt;依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过 “foo.c”调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的 C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。&lt;/p&gt;
&lt;h5&gt;2、隐含规则一览&lt;/h5&gt;
&lt;p&gt;这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数“-r”或“--no-builtin-rules”选项来取消所有的预设置的隐含规则。&lt;/p&gt;
&lt;p&gt;当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表 ”（也就一系统定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。具体的细节，我们会在后面讲述。&lt;/p&gt;
&lt;p&gt;还是先来看一看常用的隐含规则吧。&lt;/p&gt;
&lt;p&gt;1、编译C程序的隐含规则。&lt;/p&gt;
&lt;p&gt;“&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.c”，并且其生成命令是“$(CC) –c $(CPPFLAGS) $(CFLAGS)”&lt;/p&gt;
&lt;p&gt;2、编译C++程序的隐含规则。&lt;/p&gt;
&lt;p&gt;“&lt;n&gt;.o” 的目标的依赖目标会自动推导为“&lt;n&gt;.cc”或是“&lt;n&gt;.C”，并且其生成命令是“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而不是“.C”）&lt;/p&gt;
&lt;p&gt;3、编译Pascal程序的隐含规则。&lt;/p&gt;
&lt;p&gt;“&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.p”，并且其生成命令是“$(PC) –c $(PFLAGS)”。&lt;/p&gt;
&lt;p&gt;4、编译Fortran/Ratfor程序的隐含规则。&lt;/p&gt;
&lt;p&gt;“&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.r”或“&lt;n&gt;.F”或“&lt;n&gt;.f”，并且其生成命令是:&lt;/p&gt;
&lt;p&gt;“.f” “$(FC) –c $(FFLAGS)”&lt;/p&gt;
&lt;p&gt;“.F” “$(FC) –c $(FFLAGS) $(CPPFLAGS)”&lt;/p&gt;
&lt;p&gt;“.f” “$(FC) –c $(FFLAGS) $(RFLAGS)”&lt;/p&gt;
&lt;p&gt;5、预处理Fortran/Ratfor程序的隐含规则。&lt;/p&gt;
&lt;p&gt;“&lt;n&gt;.f”的目标的依赖目标会自动推导为“&lt;n&gt;.r”或“&lt;n&gt;.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：&lt;/p&gt;
&lt;p&gt;“.F” “$(FC) –F $(CPPFLAGS) $(FFLAGS)”&lt;/p&gt;
&lt;p&gt;“.r” “$(FC) –F $(FFLAGS) $(RFLAGS)”&lt;/p&gt;
&lt;p&gt;6、编译Modula-2程序的隐含规则。&lt;/p&gt;
&lt;p&gt;“&lt;n&gt;.sym” 的目标的依赖目标会自动推导为“&lt;n&gt;.def”，并且其生成命令是：“&lt;span class="math"&gt;\((M2C) $(M2FLAGS) $(DEFFLAGS)”。“&amp;lt;n.o&amp;gt;” 的目标的依赖目标会自动推导为“&amp;lt;n&amp;gt;.mod”，并且其生成命令是：“\)&lt;/span&gt;(M2C) $(M2FLAGS) $(MODFLAGS)”。&lt;/p&gt;
&lt;p&gt;7、汇编和汇编预处理的隐含规则。&lt;/p&gt;
&lt;p&gt;“&lt;n&gt;.o” 的目标的依赖目标会自动推导为“&lt;n&gt;.s”，默认使用编译品“as”，并且其生成命令是：“&lt;span class="math"&gt;\((AS) $(ASFLAGS)”。“&amp;lt;n&amp;gt;.s” 的目标的依赖目标会自动推导为“&amp;lt;n&amp;gt;.S”，默认使用C预编译器“cpp”，并且其生成命令是：“\)&lt;/span&gt;(AS) $(ASFLAGS)”。&lt;/p&gt;
&lt;p&gt;8、链接Object文件的隐含规则。&lt;/p&gt;
&lt;p&gt;“&lt;n&gt;” 目标依赖于“&lt;n&gt;.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS)”。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：&lt;/p&gt;
&lt;p&gt;x : y.o z.o&lt;/p&gt;
&lt;p&gt;并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：&lt;/p&gt;
&lt;p&gt;cc -c x.c -o x.o&lt;/p&gt;
&lt;p&gt;cc -c y.c -o y.o&lt;/p&gt;
&lt;p&gt;cc -c z.c -o z.o&lt;/p&gt;
&lt;p&gt;cc x.o y.o z.o -o x&lt;/p&gt;
&lt;p&gt;rm -f x.o&lt;/p&gt;
&lt;p&gt;rm -f y.o&lt;/p&gt;
&lt;p&gt;rm -f z.o&lt;/p&gt;
&lt;p&gt;如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。&lt;/p&gt;
&lt;p&gt;9、Yacc C程序时的隐含规则。&lt;/p&gt;
&lt;p&gt;“&lt;n&gt;.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“$(YACC) $(YFALGS)”。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）&lt;/p&gt;
&lt;p&gt;10、Lex C程序时的隐含规则。&lt;/p&gt;
&lt;p&gt;“&lt;n&gt;.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。（关于“Lex”的细节请查看相关资料）&lt;/p&gt;
&lt;p&gt;11、Lex Ratfor程序时的隐含规则。&lt;/p&gt;
&lt;p&gt;“&lt;n&gt;.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。&lt;/p&gt;
&lt;p&gt;12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。&lt;/p&gt;
&lt;p&gt;“&lt;n&gt;.ln” （lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”。对于“&lt;n&gt;.y”和“&lt;n&gt;.l”也是同样的规则。&lt;/p&gt;
&lt;h5&gt;3、隐含规则使用的变量&lt;/h5&gt;
&lt;p&gt;在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“--no– builtin-variables”参数来取消你所定义的变量对隐含规则的作用。例如，第一条隐含规则——编译C程序的隐含规则的命令是“&lt;span class="math"&gt;\((CC) –c $(CFLAGS) $(CPPFLAGS)”。Make默认的编译命令是“cc”，如果你把变量“\)&lt;/span&gt;(CC)”重定义成“gcc”，把变量“$(CFLAGS)”重定义成 “-g”，那么，隐含规则中的命令全部会以“gcc –c -g $(CPPFLAGS)”的样子来执行了。&lt;/p&gt;
&lt;p&gt;我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量：&lt;/p&gt;
&lt;h6&gt;3.1、关于命令的变量。&lt;/h6&gt;
&lt;p&gt;AR&lt;/p&gt;
&lt;p&gt;函数库打包程序。默认命令是“ar”。&lt;/p&gt;
&lt;p&gt;AS&lt;/p&gt;
&lt;p&gt;汇编语言编译程序。默认命令是“as”。&lt;/p&gt;
&lt;p&gt;CC&lt;/p&gt;
&lt;p&gt;C语言编译程序。默认命令是“cc”。&lt;/p&gt;
&lt;p&gt;CXX&lt;/p&gt;
&lt;p&gt;C++语言编译程序。默认命令是“g++”。&lt;/p&gt;
&lt;p&gt;CO&lt;/p&gt;
&lt;p&gt;从 RCS文件中扩展文件程序。默认命令是“co”。&lt;/p&gt;
&lt;p&gt;CPP&lt;/p&gt;
&lt;p&gt;C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。&lt;/p&gt;
&lt;p&gt;FC&lt;/p&gt;
&lt;p&gt;Fortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。&lt;/p&gt;
&lt;p&gt;GET&lt;/p&gt;
&lt;p&gt;从SCCS文件中扩展文件的程序。默认命令是“get”。&lt;/p&gt;
&lt;p&gt;LEX&lt;/p&gt;
&lt;p&gt;Lex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。&lt;/p&gt;
&lt;p&gt;PC&lt;/p&gt;
&lt;p&gt;Pascal语言编译程序。默认命令是“pc”。&lt;/p&gt;
&lt;p&gt;YACC&lt;/p&gt;
&lt;p&gt;Yacc文法分析器（针对于C程序）。默认命令是“yacc”。&lt;/p&gt;
&lt;p&gt;YACCR&lt;/p&gt;
&lt;p&gt;Yacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。&lt;/p&gt;
&lt;p&gt;MAKEINFO&lt;/p&gt;
&lt;p&gt;转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。&lt;/p&gt;
&lt;p&gt;TEX&lt;/p&gt;
&lt;p&gt;从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。&lt;/p&gt;
&lt;p&gt;TEXI2DVI&lt;/p&gt;
&lt;p&gt;从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。&lt;/p&gt;
&lt;p&gt;WEAVE&lt;/p&gt;
&lt;p&gt;转换Web到TeX的程序。默认命令是“weave”。&lt;/p&gt;
&lt;p&gt;CWEAVE&lt;/p&gt;
&lt;p&gt;转换C Web 到 TeX的程序。默认命令是“cweave”。&lt;/p&gt;
&lt;p&gt;TANGLE&lt;/p&gt;
&lt;p&gt;转换Web到Pascal语言的程序。默认命令是“tangle”。&lt;/p&gt;
&lt;p&gt;CTANGLE&lt;/p&gt;
&lt;p&gt;转换C Web 到 C。默认命令是“ctangle”。&lt;/p&gt;
&lt;p&gt;RM&lt;/p&gt;
&lt;p&gt;删除文件命令。默认命令是“rm –f”。&lt;/p&gt;
&lt;h6&gt;3.2、关于命令参数的变量&lt;/h6&gt;
&lt;p&gt;下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。&lt;/p&gt;
&lt;p&gt;ARFLAGS&lt;/p&gt;
&lt;p&gt;函数库打包程序AR命令的参数。默认值是“rv”。&lt;/p&gt;
&lt;p&gt;ASFLAGS&lt;/p&gt;
&lt;p&gt;汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。&lt;/p&gt;
&lt;p&gt;CFLAGS&lt;/p&gt;
&lt;p&gt;C语言编译器参数。&lt;/p&gt;
&lt;p&gt;CXXFLAGS&lt;/p&gt;
&lt;p&gt;C++语言编译器参数。&lt;/p&gt;
&lt;p&gt;COFLAGS&lt;/p&gt;
&lt;p&gt;RCS命令参数。&lt;/p&gt;
&lt;p&gt;CPPFLAGS&lt;/p&gt;
&lt;p&gt;C预处理器参数。（ C 和 Fortran 编译器也会用到）。&lt;/p&gt;
&lt;p&gt;FFLAGS&lt;/p&gt;
&lt;p&gt;Fortran语言编译器参数。&lt;/p&gt;
&lt;p&gt;GFLAGS&lt;/p&gt;
&lt;p&gt;SCCS “get”程序参数。&lt;/p&gt;
&lt;p&gt;LDFLAGS&lt;/p&gt;
&lt;p&gt;链接器参数。（如：“ld”）&lt;/p&gt;
&lt;p&gt;LFLAGS&lt;/p&gt;
&lt;p&gt;Lex文法分析器参数。&lt;/p&gt;
&lt;p&gt;PFLAGS&lt;/p&gt;
&lt;p&gt;Pascal语言编译器参数。&lt;/p&gt;
&lt;p&gt;RFLAGS&lt;/p&gt;
&lt;p&gt;Ratfor 程序的Fortran 编译器参数。&lt;/p&gt;
&lt;p&gt;YFLAGS&lt;/p&gt;
&lt;p&gt;Yacc文法分析器参数。&lt;/p&gt;
&lt;h5&gt;4、隐含规则链&lt;/h5&gt;
&lt;p&gt;有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。&lt;/p&gt;
&lt;p&gt;在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。&lt;/p&gt;
&lt;p&gt;我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？&lt;/p&gt;
&lt;p&gt;在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm -f”删除。&lt;/p&gt;
&lt;p&gt;通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE ： mid ）&lt;/p&gt;
&lt;p&gt;你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY : sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。&lt;/p&gt;
&lt;p&gt;在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。&lt;/p&gt;
&lt;p&gt;Make 会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make会编译生成中间文件“foo.o”，然后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成（cc –o foo foo.c），于是优化过的规则就不会生成中间文件。&lt;/p&gt;
&lt;h5&gt;5、定义模式规则&lt;/h5&gt;
&lt;p&gt;你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有"%"字符。"%"的意思是表示一个或多个任意字符。在依赖目标中同样可以使用"%"，只是依赖目标中的"%"的取值，取决于其目标。&lt;/p&gt;
&lt;p&gt;有一点需要注意的是，"%"的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的"%"则发生在运行时。&lt;/p&gt;
&lt;p&gt;1、模式规则介绍&lt;/p&gt;
&lt;p&gt;模式规则中，至少在规则的目标定义中要包含"%"，否则，就是一般的规则。目标中的"%"定义表示对文件名的匹配，"%"表示长度任意的非空字符串。例如："%.c"表示以".c"结尾的文件名（文件名的长度至少为3），而"s.%.c"则表示以"s."开头，".c"结尾的文件名（文件名的长度至少为 5）。&lt;/p&gt;
&lt;p&gt;如果"%"定义在目标中，那么，目标中的"%"的值决定了依赖目标中的"%"的值，也就是说，目标中的模式的"%"决定了依赖目标中"%"的样子。例如有一个模式规则如下：&lt;/p&gt;
&lt;p&gt;%.o : %.c ; &lt;command ......&gt;&lt;/p&gt;
&lt;p&gt;其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是"a.o b.o"，那么"%c"就是"a.c b.c"。&lt;/p&gt;
&lt;p&gt;一旦依赖目标中的"%"模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。&lt;/p&gt;
&lt;p&gt;2、模式规则示例&lt;/p&gt;
&lt;p&gt;下面这个例子表示了，把所有的[.c]文件都编译成[.o]文件。&lt;/p&gt;
&lt;p&gt;%.o : %.c&lt;/p&gt;
&lt;p&gt;$(CC) -c $(CFLAGS) $(CPPFLAGS) $&amp;lt; -o $@&lt;/p&gt;
&lt;p&gt;其中，"&lt;span class="math"&gt;\(@"表示所有的目标的挨个值，"\)&lt;/span&gt;&amp;lt;"表示了所有依赖目标的挨个值。这些奇怪的变量我们叫"自动化变量"，后面会详细讲述。&lt;/p&gt;
&lt;p&gt;下面的这个例子中有两个目标是模式的：&lt;/p&gt;
&lt;p&gt;%.tab.c %.tab.h: %.y&lt;/p&gt;
&lt;p&gt;bison -d $&amp;lt;&lt;/p&gt;
&lt;p&gt;这条规则告诉make把所有的[.y]文件都以"bison -d &lt;n&gt;.y"执行，然后生成"&lt;n&gt;.tab.c"和"&lt;n&gt;.tab.h"文件。（其中，"&lt;n&gt;" 表示一个任意字符串）。如果我们的执行程序"foo"依赖于文件"parse.tab.o"和"scan.o"，并且文件"scan.o"依赖于文件"parse.tab.h"，如果"parse.y"文件被更新了，那么根据上述的规则，"bison -d parse.y"就会被执行一次，于是，"parse.tab.o"和"scan.o"的依赖文件就齐了。（假设，"parse.tab.o" 由"parse.tab.c"生成，和"scan.o"由"scan.c"生成，而"foo"由"parse.tab.o"和"scan.o"链接生成，而且foo和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足）&lt;/p&gt;
&lt;p&gt;3、自动化变量&lt;/p&gt;
&lt;p&gt;在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。&lt;/p&gt;
&lt;p&gt;自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。&lt;/p&gt;
&lt;p&gt;下面是所有的自动化变量及其说明：&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(@表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，"\)&lt;/span&gt;@"就是匹配于目标中模式定义的集合。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(%仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是"foo.a(bar.o)"，那么，"\)&lt;/span&gt;%"就是"bar.o"，"$@"就是"foo.a"。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(&amp;lt;依赖目标中的第一个目标名字。如果依赖目标是以模式（即"%"）定义的，那么"\)&lt;/span&gt;&amp;lt;"将是符 
合模式的一系列的文件集。注意，其是一个一个取出来的。&lt;/p&gt;
&lt;p&gt;$?所有比目标新的依赖目标的集合。以空格分隔。&lt;/p&gt;
&lt;p&gt;$^所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(+这个变量很像"\)&lt;/span&gt;^"，也是所有依赖目标的集合。只是它不去除重复的依赖目标。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(*这个变量表示目标模式中"%"及其之前的部分。如果目标是"dir/a.foo.b"，并且目标的模式是"a.%.b"，那么，"\)&lt;/span&gt;&lt;em&gt;"的值就是"dir /a.foo"。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么"&lt;span class="math"&gt;\(*"也就不能被推导出，但是，如果目标文件的后缀是 make所识别的，那么"\)&lt;/span&gt;&lt;/em&gt;"就是除了后缀的那一部分。例如：如果目标是"foo.c"，因为".c"是make所能识别的后缀名，所以，"&lt;span class="math"&gt;\(*"的值就是"foo"。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用"\)&lt;/span&gt;&lt;em&gt;"，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么"$&lt;/em&gt;"就是空值。&lt;/p&gt;
&lt;p&gt;当你希望只对更新过的依赖文件进行操作时，"$?"在显式规则中很有用，例如，假设有一个函数库文件叫"lib"，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：&lt;/p&gt;
&lt;p&gt;lib : foo.o bar.o lose.o win.o&lt;/p&gt;
&lt;p&gt;ar r lib $?&lt;/p&gt;
&lt;p&gt;在上述所列出来的自动量变量中。四个变量（&lt;span class="math"&gt;\(@、\)&lt;/span&gt;&amp;lt;、&lt;span class="math"&gt;\(%、\)&lt;/span&gt;*）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上"D"或"F"字样。这是GNU make中老版本的特性，在新版本中，我们使用函数"dir"或"notdir"就可以做到了。"D"的含义就是Directory，就是目录，"F"的含义就是File，就是文件。&lt;/p&gt;
&lt;p&gt;下面是对于上面的七个变量分别加上"D"或是"F"的含义：&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\((@D)表示"\)&lt;/span&gt;@"的目录部分（不以斜杠作为结尾），如果"&lt;span class="math"&gt;\(@"值是"dir/foo.o"，那么"\)&lt;/span&gt;(@D)"就是"dir"，而如果"$@"中没有包含斜杠的话，其值就是"."（当前目录）。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\((@F)表示"\)&lt;/span&gt;@"的文件部分，如果"&lt;span class="math"&gt;\(@"值是"dir/foo.o"，那么"\)&lt;/span&gt;(@F)"就是"foo.o"，"&lt;span class="math"&gt;\((@F)"相当于函数"\)&lt;/span&gt;(notdir $@)"。&lt;/p&gt;
&lt;p&gt;"&lt;span class="math"&gt;\((*D)""\)&lt;/span&gt;(&lt;em&gt;F)"和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，"&lt;span class="math"&gt;\((*D)"返回"dir"，而"\)&lt;/span&gt;(&lt;/em&gt;F)"返回"foo"&lt;/p&gt;
&lt;p&gt;"&lt;span class="math"&gt;\((%D)""\)&lt;/span&gt;(%F)"分别表示了函数包文件成员的目录部分和文件部分。这对于形同"archive(member)"形式的目标中的"member"中包含了不同的目录很有用。&lt;/p&gt;
&lt;p&gt;"&lt;span class="math"&gt;\((&amp;lt;D)""\)&lt;/span&gt;(&amp;lt;F)"分别表示依赖文件的目录部分和文件部分。&lt;/p&gt;
&lt;p&gt;"&lt;span class="math"&gt;\((^D)""\)&lt;/span&gt;(^F)"分别表示所有依赖文件的目录部分和文件部分。（无相同的）&lt;/p&gt;
&lt;p&gt;"&lt;span class="math"&gt;\((+D)""\)&lt;/span&gt;(+F)"分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）&lt;/p&gt;
&lt;p&gt;"&lt;span class="math"&gt;\((?D)""\)&lt;/span&gt;(?F)"分别表示被更新的依赖文件的目录部分和文件部分。&lt;/p&gt;
&lt;p&gt;最后想提醒一下的是，对于"&lt;span class="math"&gt;\(&amp;lt;"，为了避免产生不必要的麻烦，我们最好给\)&lt;/span&gt;后面的那个特定字符都加上圆括号，比如，"&lt;span class="math"&gt;\((&amp;lt; )"就要比"\)&lt;/span&gt;&amp;lt;"要好一些。&lt;/p&gt;
&lt;p&gt;还得要注意的是，这些变量只使用在规则的命令中，而且一般都是"显式规则"和"静态模式规则"（参见前面"书写规则"一章）。其在隐含规则中并没有意义。&lt;/p&gt;
&lt;p&gt;4、模式的匹配&lt;/p&gt;
&lt;p&gt;一般来说，一个目标的模式有一个有前缀或是后缀的"%"，或是没有前后缀，直接就是一个"%"。因为"%"代表一个或多个字符，所以在定义好了的模式中，我们把"%"所匹配的内容叫做"茎"，例如"%.c"所匹配的文件"test.c"中"test"就是"茎"。因为在目标和依赖目标中同时有"%"时，依赖目标的"茎"会传给目标，当做目标中的"茎"。&lt;/p&gt;
&lt;p&gt;当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行"茎"的传递时，我们需要知道这个步骤。例如有一个模式"e%t"，文件"src/eat" 匹配于该模式，于是"src/a"就是其"茎"，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式"c%r"，那么，目标就是"src/car"。（"茎"被传递）&lt;/p&gt;
&lt;p&gt;5、重载内建隐含规则&lt;/p&gt;
&lt;p&gt;你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;%.o : %.c&lt;/span&gt;

$&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CC&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; $&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CPPFLAGS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; $&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CFLAGS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;$&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你可以取消内建的隐含规则，只要不在后面写命令就行。如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;%.o : %.s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。&lt;/p&gt;
&lt;h5&gt;6、老式风格的"后缀规则"&lt;/h5&gt;
&lt;p&gt;后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式："双后缀"和"单后缀"。&lt;/p&gt;
&lt;p&gt;双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如".c.o"相当于"%o : %c"。单后缀规则只定义一个后缀，也就是源文件的后缀。如".c"相当于"% : %.c"。&lt;/p&gt;
&lt;p&gt;后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：".c"和".o"都是make所知道。因而，如果你定义了一个规则是".c.o"那么其就是双后缀规则，意义就是".c" 是源文件的后缀，".o"是目标文件的后缀。如下示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;.c.o:&lt;/span&gt;

&lt;span class="nf"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CC&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="no"&gt;c&lt;/span&gt; &lt;span class="no"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CFLAGS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CPPFLAGS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="no"&gt;o&lt;/span&gt; &lt;span class="no"&gt;$@&lt;/span&gt; &lt;span class="no"&gt;$&lt;/span&gt;&lt;span class="err"&gt;&amp;lt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;.c.o:&lt;/span&gt; &lt;span class="nf"&gt;foo.h&lt;/span&gt;

&lt;span class="nf"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CC&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="no"&gt;c&lt;/span&gt; &lt;span class="no"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CFLAGS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CPPFLAGS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="no"&gt;o&lt;/span&gt; &lt;span class="no"&gt;$@&lt;/span&gt; &lt;span class="no"&gt;$&lt;/span&gt;&lt;span class="err"&gt;&amp;lt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个例子，就是说，文件".c.o"依赖于文件"foo.h"，而不是我们想要的这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;%.o: %.c foo.h&lt;/span&gt;

$&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CC&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; $&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CFLAGS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; $&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CPPFLAGS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; $&lt;span class="p"&gt;@&lt;/span&gt; $&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。&lt;/p&gt;
&lt;p&gt;而要让make知道一些特定的后缀，我们可以使用伪目标".SUFFIXES"来定义或是删除，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;.SUFFIXES:&lt;/span&gt; &lt;span class="na"&gt;.hack&lt;/span&gt; &lt;span class="no"&gt;.win&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把后缀.hack和.win加入后缀列表中的末尾。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;.SUFFIXES:&lt;/span&gt; &lt;span class="c"&gt;# 删除默认的后缀&lt;/span&gt;

&lt;span class="nl"&gt;.SUFFIXES:&lt;/span&gt; &lt;span class="na"&gt;.c&lt;/span&gt; &lt;span class="no"&gt;.o&lt;/span&gt; &lt;span class="no"&gt;.h&lt;/span&gt; &lt;span class="c"&gt;# 定义自己的后缀&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;先清除默认后缀，后定义自己的后缀列表。&lt;/p&gt;
&lt;p&gt;make的参数"-r"或"-no-builtin-rules"也会使用得默认的后缀列表为空。而变量"SUFFIXE"被用来定义默认的后缀列表，你可以用".SUFFIXES"来改变后缀列表，但请不要改变变量"SUFFIXE"的值。&lt;/p&gt;
&lt;h5&gt;7、隐含规则搜索算法&lt;/h5&gt;
&lt;p&gt;比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是"archive(member)"的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把"member"当作T来搜索。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是"src/foo.o"，那么，D就是"src/"，N就是"foo.o"）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、创建所有匹配于T或是N的模式规则列表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3、如果在模式规则列表中有匹配所有文件的模式，如"%"，那么从列表中移除其它的模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4、移除列表中没有命令的规则。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5、对于第一个在列表中的模式规则：&lt;/p&gt;
&lt;p&gt;*1）推导其"茎"S，S应该是T或是N匹配于模式中"%"非空的部分。&lt;/p&gt;
&lt;p&gt;*2）计算依赖文件。把依赖文件中的"%"都替换成"茎"S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。&lt;/p&gt;
&lt;p&gt;*3）测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫"理当存在"）&lt;/p&gt;
&lt;p&gt;*4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;6、如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：&lt;/p&gt;
&lt;p&gt;*1）如果规则是终止规则，那就忽略它，继续下一条模式规则。&lt;/p&gt;
&lt;p&gt;*2）计算依赖文件。（同第5步）&lt;/p&gt;
&lt;p&gt;*3）测试所有的依赖文件是否存在或是理当存在。&lt;/p&gt;
&lt;p&gt;*4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。&lt;/p&gt;
&lt;p&gt;*5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;7、如果没有隐含规则可以使用，查看".DEFAULT"规则，如果有，采用，把".DEFAULT"的命令给T使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。&lt;/p&gt;
&lt;h4&gt;十七、使用make更新函数库文件&lt;/h4&gt;
&lt;p&gt;函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令"ar"来完成打包工作。&lt;/p&gt;
&lt;h5&gt;1、函数库文件的成员&lt;/h5&gt;
&lt;p&gt;一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;archive(member)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了"ar"命令来服务的。如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;foolib(hack.o) : hack.o

ar cr foolib hack.o
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果要指定多个member，那就以空格分开，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;foolib(hack.o kludge.o)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其等价于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;foolib(hack.o) foolib(kludge.o)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你还可以使用Shell的文件通配符来定义，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;foolib(*.o)
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;3、函数库成员的隐含规则&lt;/h5&gt;
&lt;p&gt;当 make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是"a(m)"形式的，其会把目标变成"(m)"。于是，如果我们的成员是"%.o" 的模式定义，并且如果我们使用"make foo.a(bar.o)"的形式调用Makefile时，隐含规则会去找"bar.o"的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cc -c bar.c -o bar.o

ar r foo.a bar.o

rm -f bar.o
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还有一个变量要注意的是"$%"，这是专属函数库文件的自动化变量，有关其说明请参见"自动化变量"一节。&lt;/p&gt;
&lt;h5&gt;3、函数库文件的后缀规则&lt;/h5&gt;
&lt;p&gt;你可以使用"后缀规则"和"隐含规则"来生成函数库打包文件，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;.c.a:&lt;/span&gt;

&lt;span class="nf"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CC&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CFLAGS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;CPPFLAGS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="no"&gt;c&lt;/span&gt; &lt;span class="no"&gt;$&lt;/span&gt;&lt;span class="err"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="no"&gt;o&lt;/span&gt; &lt;span class="no"&gt;$&lt;/span&gt;&lt;span class="p"&gt;*.&lt;/span&gt;&lt;span class="no"&gt;o&lt;/span&gt;

&lt;span class="nf"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;AR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;r&lt;/span&gt; &lt;span class="no"&gt;$@&lt;/span&gt; &lt;span class="no"&gt;$&lt;/span&gt;&lt;span class="p"&gt;*.&lt;/span&gt;&lt;span class="no"&gt;o&lt;/span&gt;

 &lt;span class="nf"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;RM&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;$&lt;/span&gt;&lt;span class="p"&gt;*.&lt;/span&gt;&lt;span class="no"&gt;o&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其等效于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;(%.o) &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; %.&lt;span class="n"&gt;c&lt;/span&gt;

&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;CC&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;CFLAGS&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;CPPFLAGS&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="err"&gt;-c&lt;/span&gt; &lt;span class="k"&gt;$&amp;lt;&lt;/span&gt; &lt;span class="err"&gt;-o&lt;/span&gt; &lt;span class="k"&gt;$*&lt;/span&gt;&lt;span class="err"&gt;.o&lt;/span&gt;

&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;AR&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="err"&gt;r&lt;/span&gt; &lt;span class="k"&gt;$@&lt;/span&gt; &lt;span class="k"&gt;$*&lt;/span&gt;&lt;span class="err"&gt;.o&lt;/span&gt;

&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;RM&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$*&lt;/span&gt;&lt;span class="err"&gt;.o&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;4、注意事项&lt;/h4&gt;
&lt;p&gt;在进行函数库打包文件生成时，请小心使用make的并行机制（"-j"参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。&lt;/p&gt;
&lt;p&gt;但就目前而言，你还是应该不要尽量不要使用"-j"参数。&lt;/p&gt;
&lt;p&gt;最后，我还想介绍一下make程序的设计开发者。&lt;/p&gt;
&lt;p&gt;首当其冲的是： Richard Stallman开源软件的领袖和先驱，从来没有领过一天工资，从来没有使用过Windows操作系统。对于他的事迹和他的软件以及他的思想，我无需说过多的话，相信大家对这个人并不比我陌生，这是他的主页：&lt;a href="http://www.stallman.org/"&gt;Richard Stallman&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;第二位是：Roland McGrath个人主页是：&lt;a href="http://www.frob.com/~roland/"&gt;Roland McGrath&lt;/a&gt; ，下面是他的一些事迹：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1） 合作编写了并维护GNU make。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2） 和Thomas Bushnell一同编写了GNU Hurd。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3） 编写并维护着GNU C library。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4） 合作编写并维护着部分的GNU Emacs。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在此，向这两位开源项目的斗士致以最真切的敬意。&lt;/p&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="Makefile"></category></entry></feed>